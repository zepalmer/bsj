package edu.jhu.cs.bsj.tests.compiler.tool.compiler;

import static org.junit.Assert.fail;

import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardLocation;
import javax.tools.ToolProvider;
import javax.tools.JavaFileObject.Kind;

import junit.framework.Assert;

import org.junit.Test;

import edu.jhu.cs.bsj.compiler.ast.BsjNodeFactory;
import edu.jhu.cs.bsj.compiler.ast.NameCategory;
import edu.jhu.cs.bsj.compiler.ast.node.CompilationUnitNode;
import edu.jhu.cs.bsj.compiler.ast.node.ExpressionNode;
import edu.jhu.cs.bsj.compiler.ast.node.Node;
import edu.jhu.cs.bsj.compiler.impl.ast.BsjNodeFactoryImpl;
import edu.jhu.cs.bsj.compiler.impl.tool.compiler.BsjTreeLifter;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.BsjFileManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.BsjFileObject;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.InMemoryLocationManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.LocationManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.LocationMappedFileManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.UnionLocationManager;
import edu.jhu.cs.bsj.compiler.impl.tool.serializer.BsjSourceSerializerImpl;
import edu.jhu.cs.bsj.compiler.tool.parser.BsjParserImpl;


public class BsjTreeLifterTest
{
	private static final String[] META_IMPORTS = { 
		"edu.jhu.cs.bsj.compiler.ast.*",
		"edu.jhu.cs.bsj.compiler.ast.node.*", 
		"edu.jhu.cs.bsj.compiler.impl.ast.BsjNodeFactoryImpl",
		"edu.jhu.cs.bsj.compiler.ast.node.meta.*", 
		"java.util.*"
		};
	/* 
	 * TODO
	 * 1.  Grab an example source file (similar to the RegeneratorTest)
	 * 2.  Parse it into an AST
	 * 3.  Pass the AST into the Lifter
	 * 4.  Embed the block from the Lifter into some wrapper code
	 * 5.  Compile and run the code from the Lifter using the wrapper code
	 * 6.  Take the AST generated by the lifted code and pass it through the Regenerator,
	 * 	   the result should be equal to the original example source
	 *     (after being passed through the regenerator as well)
	 */

    
    @Test
    public void testMetaGeneration()
    {
        BsjNodeFactory factory = new BsjNodeFactoryImpl();
        BsjTreeLifter treeLifter = new BsjTreeLifter(factory);       
        BsjParserImpl parser = new BsjParserImpl(new BsjNodeFactoryImpl());
        
        String baseCode = 
                "public class BaseClass " + 
                "{" + 
                    "public int foo()" + 
                    "{return 666;}" + 
                "}";
        
        Node ast = null;
        try
        {
            ast = parser.parse(new InputStreamReader(new ByteArrayInputStream(baseCode.getBytes())));
        } catch (Exception e)
        {
            e.printStackTrace();
            fail(e.getMessage());
        }
        
        
        ExpressionNode metaFactory = factory.makeFieldAccessByNameNode(factory.makeSimpleNameNode(factory.makeIdentifierNode("factory"), NameCategory.TYPE));
        
        ExpressionNode metaAst = ast.executeOperation(treeLifter, metaFactory);
        System.out.println("=");
        try
		{
			System.out.println(compileMeta(metaAst).executeOperation(new BsjSourceSerializerImpl(), null));
		} 
        catch (Exception e)
		{
			e.printStackTrace();
			fail(e.getMessage());
		}
	}
    
    /**
     * Compiles and runs a block of code which generates a lifted AST.
     * @param code
     * @return the lifted AST.
     */
    public CompilationUnitNode compileMeta(ExpressionNode code) throws Exception
    {
    	// build the source for the wrapper that runs the lifted code
    	StringBuilder sb = new StringBuilder();
		for (String s : META_IMPORTS)
		{
			sb.append("import ").append(s).append(";\n");
		}
        sb.append("public class WrapperClass\n{\npublic Node runLiftedCode()\n{\n");
        sb.append("BsjNodeFactory factory = new BsjNodeFactoryImpl();\nreturn ");
        sb.append(code.executeOperation(new BsjSourceSerializerImpl(), null));
        String wrapperCode = sb.append(";\n}\n}").toString();
        
        // compile the wrapper...
        JavaCompiler jc = ToolProvider.getSystemJavaCompiler();
		Map<StandardLocation, LocationManager> map = new HashMap<StandardLocation, LocationManager>();
		map.put(StandardLocation.SOURCE_PATH, new InMemoryLocationManager(null));
		map.put(StandardLocation.SOURCE_OUTPUT, new InMemoryLocationManager(null));
		map.put(StandardLocation.PLATFORM_CLASS_PATH, new UnionLocationManager(null,
				System.getProperty("sun.boot.class.path")));
		map.put(StandardLocation.CLASS_PATH, new UnionLocationManager(null, 
				System.getProperty("java.class.path")));
		map.put(StandardLocation.CLASS_OUTPUT, new InMemoryLocationManager(null));
		map.put(StandardLocation.ANNOTATION_PROCESSOR_PATH, new InMemoryLocationManager(null));
		BsjFileManager bfm = new LocationMappedFileManager(map);
        
        // get our source file
		BsjFileObject bfo = bfm.getJavaFileForOutput(StandardLocation.SOURCE_PATH, "WrapperClass", Kind.SOURCE, null);
		bfo.setCharContent(wrapperCode);
		List<JavaFileObject> fileObjects = Arrays.<JavaFileObject> asList(bfo);

		// compile
		if (!(jc.getTask(null, bfm, null, null, null, fileObjects).call()))
		{
			Assert.fail("Compilation failure.");
		}
		bfm.close();

		// run the wrapper and return the node created by the lifted code
		Class<?> wrapper = bfm.getClassLoader(StandardLocation.CLASS_OUTPUT).loadClass("WrapperClass");
      	Method method = wrapper.getDeclaredMethod("runLiftedCode", (Class<?>[])null);
      	Object object = wrapper.newInstance();
        return (CompilationUnitNode) method.invoke(object, (Object[])null);
    }
   
    
    
}
