package edu.jhu.cs.bsj.tests.compiler.tool.compiler;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardLocation;
import javax.tools.ToolProvider;
import javax.tools.JavaFileObject.Kind;

import junit.framework.Assert;

import org.junit.Test;

import edu.jhu.cs.bsj.compiler.ast.BsjNodeFactory;
import edu.jhu.cs.bsj.compiler.ast.NameCategory;
import edu.jhu.cs.bsj.compiler.ast.node.CompilationUnitNode;
import edu.jhu.cs.bsj.compiler.ast.node.ExpressionNode;
import edu.jhu.cs.bsj.compiler.ast.node.Node;
import edu.jhu.cs.bsj.compiler.impl.ast.BsjNodeFactoryImpl;
import edu.jhu.cs.bsj.compiler.impl.tool.compiler.BsjTreeLifter;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.BsjFileManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.BsjFileObject;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.InMemoryLocationManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.LocationManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.LocationMappedFileManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.UnionLocationManager;
import edu.jhu.cs.bsj.compiler.impl.tool.serializer.BsjSourceSerializerImpl;
import edu.jhu.cs.bsj.compiler.tool.parser.BsjParserImpl;

/**
 * Tests the BsjTreeLifter using the following steps:
 * 
 * 1. Grab an example source file (similar to the RegeneratorTest) 
 * 2. Parse it into an AST 
 * 3. Pass the AST into the Lifter 
 * 4. Embed the block from the Lifter into some wrapper code 
 * 5. Compile and run the code from the Lifter using the wrapper code 
 * 6. Take the AST generated by the lifted code and pass it through the regenerator, 
 * 	  the result should be equal to the original example source 
 *    (after being passed through the regenerator as well)
 */
public class BsjTreeLifterTest
{
	private static final String[] META_IMPORTS = { 
		"edu.jhu.cs.bsj.compiler.ast.*",
		"edu.jhu.cs.bsj.compiler.ast.node.*", 
		"edu.jhu.cs.bsj.compiler.impl.ast.BsjNodeFactoryImpl",
		"edu.jhu.cs.bsj.compiler.ast.node.meta.*", 
		"java.util.*"
		};
	
	/**
	 * Test the BsjTreeLifter on files in the examples directory.
	 */
    @Test
    public void testLifterOnExamples()
    {
        File exampleDir = new File("examples");        
        findAndTestJavaFiles(exampleDir);
    }
    
    /**
     * Recursively find and test all java files in a directory.
     * @param dir the directory to search.
     */
    public void findAndTestJavaFiles(File dir)
    {
        for (File file : dir.listFiles())
        {
            if (file.isDirectory())
            {
                findAndTestJavaFiles(file);
            }
            else if (file.getName().endsWith(".java"))
			{
				System.out.println("Testing " + file.getAbsolutePath());
				assertTrue(liftJavaFile(file));
			}         
        }
    }
	
    /**
     * Attempt to lift, recompile, and regenerate a Java file, then compare to the original source.
     * @param file the file to manipulate.
     * @return true if the lifted, recompiled, and regenerated file is equal to the origina (regenerated).
     */
    public boolean liftJavaFile(File file)
    {
        BsjNodeFactory factory = new BsjNodeFactoryImpl();
        BsjTreeLifter treeLifter = new BsjTreeLifter(factory);       
        BsjParserImpl parser = new BsjParserImpl(new BsjNodeFactoryImpl());
        String factoryName = "factory";
        
        // parse the original source
        Node ast = null;
        try
        {
            ast = parser.parse(new InputStreamReader(new FileInputStream(file)));
        } catch (Exception e)
        {
            e.printStackTrace();
            fail(e.getMessage());
        }
        
        // regenerate and save the original source
        String originalProgram = ast.executeOperation(new BsjSourceSerializerImpl(), null);
        
        // create a metaFactory for use in the lifted code
        ExpressionNode metaFactory = factory.makeFieldAccessByNameNode(
        		factory.makeSimpleNameNode(
        				factory.makeIdentifierNode(factoryName), NameCategory.TYPE));
        
        // get the lifted code
        ExpressionNode metaAst = ast.executeOperation(treeLifter, metaFactory);

        // compile the lifted code and get the result
        String liftedProgram = null;
        try
		{
        	liftedProgram = compileMeta(metaAst, factoryName)
        		.executeOperation(new BsjSourceSerializerImpl(), null);
		} 
        catch (Exception e)
		{
			e.printStackTrace();
			fail(e.getMessage());
		}
                
        // compare the original (regenerated) to the lifted, recompiled and regenerated
        return originalProgram.equals(liftedProgram);
	}
    
    /**
     * Compiles and runs a block of code which generates a lifted AST.
     * @param code the AST for generating the lifted AST.
     * @param factoryName the name of the meta factory referenced in the lifted AST.
     * @return the lifted AST.
     */
    public CompilationUnitNode compileMeta(ExpressionNode code, String factoryName) throws Exception
    {
    	// build the source for the wrapper that runs the lifted code
    	StringBuilder sb = new StringBuilder();
		for (String s : META_IMPORTS)
		{
			sb.append("import ").append(s).append(";\n");
		}
        sb.append("public class WrapperClass\n{\npublic Node runLiftedCode()\n{\n");
        sb.append("BsjNodeFactory " + factoryName + " = new BsjNodeFactoryImpl();\nreturn ");
        sb.append(code.executeOperation(new BsjSourceSerializerImpl(), null));
        String wrapperCode = sb.append(";\n}\n}").toString();

        // setup the compilation environment
        JavaCompiler jc = ToolProvider.getSystemJavaCompiler();
		Map<StandardLocation, LocationManager> map = new HashMap<StandardLocation, LocationManager>();
		map.put(StandardLocation.SOURCE_PATH, new InMemoryLocationManager(null));
		map.put(StandardLocation.SOURCE_OUTPUT, new InMemoryLocationManager(null));
		map.put(StandardLocation.PLATFORM_CLASS_PATH, new UnionLocationManager(null,
				System.getProperty("sun.boot.class.path")));
		map.put(StandardLocation.CLASS_PATH, new UnionLocationManager(null, 
				System.getProperty("java.class.path")));
		map.put(StandardLocation.CLASS_OUTPUT, new InMemoryLocationManager(null));
		map.put(StandardLocation.ANNOTATION_PROCESSOR_PATH, new InMemoryLocationManager(null));
		BsjFileManager bfm = new LocationMappedFileManager(map);
        
        // get our wrapper source file
		BsjFileObject bfo = bfm.getJavaFileForOutput(StandardLocation.SOURCE_PATH, "WrapperClass", Kind.SOURCE, null);
		bfo.setCharContent(wrapperCode);
		List<JavaFileObject> fileObjects = Arrays.<JavaFileObject> asList(bfo);

		// compile
		if (!(jc.getTask(null, bfm, null, null, null, fileObjects).call()))
		{
			Assert.fail("Compilation failure.");
		}
		bfm.close();

		// run the compiled wrapper and return the node created by the lifted code
		Class<?> wrapper = bfm.getClassLoader(StandardLocation.CLASS_OUTPUT).loadClass("WrapperClass");
      	Method method = wrapper.getDeclaredMethod("runLiftedCode", (Class<?>[])null);
      	Object object = wrapper.newInstance();
        return (CompilationUnitNode) method.invoke(object, (Object[])null);
    }    
}
