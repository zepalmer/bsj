package edu.jhu.cs.bsj.tests.compiler.tool.compiler;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardLocation;
import javax.tools.ToolProvider;
import javax.tools.JavaFileObject.Kind;

import junit.framework.Assert;

import org.junit.Test;

import edu.jhu.cs.bsj.compiler.ast.BsjNodeFactory;
import edu.jhu.cs.bsj.compiler.ast.BsjSourceSerializer;
import edu.jhu.cs.bsj.compiler.ast.NameCategory;
import edu.jhu.cs.bsj.compiler.ast.node.CompilationUnitNode;
import edu.jhu.cs.bsj.compiler.ast.node.ExpressionNode;
import edu.jhu.cs.bsj.compiler.ast.node.MethodDeclarationNode;
import edu.jhu.cs.bsj.compiler.ast.node.Node;
import edu.jhu.cs.bsj.compiler.impl.ast.BsjNodeFactoryImpl;
import edu.jhu.cs.bsj.compiler.impl.tool.compiler.BsjTreeLifter;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.BsjFileManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.BsjFileObject;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.InMemoryLocationManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.LocationManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.LocationMappedFileManager;
import edu.jhu.cs.bsj.compiler.impl.tool.filemanager.UnionLocationManager;
import edu.jhu.cs.bsj.compiler.impl.tool.serializer.BsjSourceSerializerImpl;
import edu.jhu.cs.bsj.compiler.tool.parser.BsjParserImpl;

/**
 * Tests the BsjTreeLifter using the following steps:
 * 
 * 1. Grab an example source file (similar to the RegeneratorTest) 2. Parse it into an AST 3. Pass the AST into the
 * Lifter 4. Embed the block from the Lifter into some wrapper code 5. Compile and run the code from the Lifter using
 * the wrapper code 6. Take the AST generated by the lifted code and pass it through the regenerator, the result should
 * be equal to the original example source (after being passed through the regenerator as well)
 */
public class BsjTreeLifterTest
{
	// private variables used in testing
	private static final String[] META_IMPORTS = { "edu.jhu.cs.bsj.compiler.ast.*",
			"edu.jhu.cs.bsj.compiler.ast.node.*", "edu.jhu.cs.bsj.compiler.impl.ast.BsjNodeFactoryImpl",
			"edu.jhu.cs.bsj.compiler.ast.node.meta.*", "java.util.*" };	
//	private BsjNodeFactory factory = new BsjNodeFactoryImpl();
//	private BsjTreeLifter treeLifter = new BsjTreeLifter(factory);
//	private BsjParserImpl parser = new BsjParserImpl(new BsjNodeFactoryImpl());
//	private String factoryName = "factory";
//	private BsjSourceSerializer serializer = new BsjSourceSerializerImpl();
	
	/**
	 * Test the BsjTreeLifter on files in the examples directory.
	 */
	@Test
	public void testLifterOnExamples()
	{
		File exampleDir = new File("examples");
		findAndTestJavaFiles(exampleDir);
	}

	/**
	 * Recursively find and test all java files in a directory.
	 * 
	 * @param dir the directory to search.
	 */
	public void findAndTestJavaFiles(File dir)
	{
		for (File file : dir.listFiles())
		{
			if (file.isDirectory())
			{
				findAndTestJavaFiles(file);
			} else if (file.getName().endsWith(".java"))
			{
				System.out.println("Testing " + file.getAbsolutePath());
				assertTrue(liftJavaFile(file));
			}
		}
	}

	/**
	 * Attempt to lift, recompile, and regenerate a Java file, then compare to the original source.
	 * 
	 * @param file the file to manipulate.
	 * @return true if the lifted, recompiled, and regenerated file is equal to the original (regenerated).
	 */
	public boolean liftJavaFile(File file)
	{
	    BsjNodeFactory factory = new BsjNodeFactoryImpl();
	    BsjTreeLifter treeLifter = new BsjTreeLifter(factory);
	    BsjParserImpl parser = new BsjParserImpl(new BsjNodeFactoryImpl());
	    String factoryName = "factory";
	    BsjSourceSerializer serializer = new BsjSourceSerializerImpl();
	    
		// parse the original source
		Node ast = null;
		try
		{
			ast = parser.parse(new InputStreamReader(new FileInputStream(file)), null);
		} catch (Exception e)
		{
			e.printStackTrace();
			fail(e.getMessage());
		}

		// regenerate and save the original source
		String originalProgram = ast.executeOperation(serializer, null);

		// create a metaFactory for use in the lifted code
		ExpressionNode metaFactory = factory.makeFieldAccessByNameNode(factory.makeSimpleNameNode(
				factory.makeIdentifierNode(factoryName), NameCategory.TYPE));

		// get the lifted code
		ExpressionNode metaAst = ast.executeOperation(treeLifter, metaFactory);
		
		//TODO replace expressions w/ methods
		List<MethodDeclarationNode> methods = divideLiftIntoMethods(metaAst);
//		System.out.println(metaAst.executeOperation(serializer, null));
//		System.out.println("methods size="+methods.size());
//		System.out.println("maxMemory="+Runtime.getRuntime().maxMemory());
//		for (int i = methods.size()-1; i >= 0; i--)
//		{
//		    System.out.println(methods.get(i).executeOperation(serializer, null));
//		}

		// compile the lifted code and get the result
		String liftedProgram = null;
		try
		{
			liftedProgram = compileMeta(metaAst, factoryName, methods).executeOperation(serializer, null);
		} catch (Exception e)
		{
			e.printStackTrace();
			fail(e.getMessage());
		}

		// compare the original (regenerated) to the lifted, recompiled and regenerated
		return originalProgram.equals(liftedProgram);
	}

	/**
	 * Mutates metaAst by removing expressions down to a certain depth and replacing them with method invocations.
	 * @param metaAst the lifted AST to be divided.
	 * @return the list of method declarations corresponding to the mutated AST.
	 */
	private List<MethodDeclarationNode> divideLiftIntoMethods(ExpressionNode metaAst)
    {
	    List<MethodDeclarationNode> methods = new ArrayList<MethodDeclarationNode>();
	    metaAst.receiveTyped(new BsjLiftedCodeVisitor(methods));
	    
        return methods;
    }

    /**
	 * Compiles and runs a block of code which generates a lifted AST.
	 * 
	 * @param code the AST for generating the lifted AST.
	 * @param factoryName the name of the meta factory referenced in the lifted AST.
     * @param methods list of method declarations for methods used in meta code
	 * @return the lifted AST.
	 */
	public CompilationUnitNode compileMeta(
			ExpressionNode code, 
			String factoryName, 
			List<MethodDeclarationNode> methods) throws Exception
	{
	    BsjSourceSerializer serializer = new BsjSourceSerializerImpl();
	    
		// build the source for the wrapper that runs the lifted code
		StringBuilder sb = new StringBuilder();
		for (String s : META_IMPORTS)
		{
			sb.append("import ").append(s).append(";\n");
		}
		sb.append("public class WrapperClass\n{\n");
		sb.append("static BsjNodeFactory " + factoryName + " = new BsjNodeFactoryImpl();\n");
		sb.append("public Node runLiftedCode()\n{\n\nreturn ");
		sb.append(code.executeOperation(serializer, null));
		sb.append(";\n}\n");
		for (MethodDeclarationNode method : methods)
		{
			sb.append(method.executeOperation(serializer, null));
			sb.append("\n");
		}
		sb.append("\n}");
		String wrapperCode = sb.toString();

		// setup the compilation environment
		JavaCompiler jc = ToolProvider.getSystemJavaCompiler();
		Map<StandardLocation, LocationManager> map = new HashMap<StandardLocation, LocationManager>();
		map.put(StandardLocation.SOURCE_PATH, new InMemoryLocationManager(null));
		map.put(StandardLocation.SOURCE_OUTPUT, new InMemoryLocationManager(null));
		map.put(StandardLocation.PLATFORM_CLASS_PATH, new UnionLocationManager(null,
				System.getProperty("sun.boot.class.path")));
		map.put(StandardLocation.CLASS_PATH, new UnionLocationManager(null, System.getProperty("java.class.path")));
		map.put(StandardLocation.CLASS_OUTPUT, new InMemoryLocationManager(null));
		map.put(StandardLocation.ANNOTATION_PROCESSOR_PATH, new InMemoryLocationManager(null));
		BsjFileManager bfm = new LocationMappedFileManager(map);

		// get our wrapper source file
		BsjFileObject bfo = bfm.getJavaFileForOutput(StandardLocation.SOURCE_PATH, "WrapperClass", Kind.SOURCE, null);
		bfo.setCharContent(wrapperCode);
		List<JavaFileObject> fileObjects = Arrays.<JavaFileObject> asList(bfo);

		// compile
		if (!(jc.getTask(null, bfm, null, null, null, fileObjects).call()))
		{
			Assert.fail("Compilation failure.");
		}
		bfm.close();

		// run the compiled wrapper and return the node created by the lifted code
		Class<?> wrapper = bfm.getClassLoader(StandardLocation.CLASS_OUTPUT).loadClass("WrapperClass");
		Method method = wrapper.getDeclaredMethod("runLiftedCode", (Class<?>[]) null);
		Object object = wrapper.newInstance();
		return (CompilationUnitNode) method.invoke(object, (Object[]) null);
	}
}
