# This file is used to describe the interfaces and classes that are used by the BSJ parser to represent ASTs.  It is
# used to generate corresponding source code manually.
#
# The format of this file is very sloppy as it is meant only to save frequent maintenance.  Any content appearing after
# a '#' on a line is a comment.  Otherwise, content may be a class description or an operation description.  Class
# descriptions are separated by line breaks.  The first line of a class description indicates the class's name and
# immediate superclass.  Each following line up until a blank line is treated as information about the class
# description.
#
# An operation description starts with a '!' character.  The syntax of an operation depends on which operation is being
# invoked.  Valid operations are:
#
#     * !set: Sets a variable for the generator.  All class descriptions which appear after this operation will be
#             affected accordingly.  The syntax is "!set name=value".  Valid names are:
#         + iPackage: Changes the package for generated interface files.
#         + cPackage: Changes the package for generated backing class files.
#         + stopGen:  A comma-separated list of items to avoid generating.  The items are generated anyway, but within
#                     a comment.  The legal items are:
#             - cons: Prevents a concrete class's constructor from being generated.
#
# The class's name and immediate superclass are separated by "::".  Additionally, the class's name may be suffixed in a
# '*' character.  If this is the case, no concrete implementation is expected.  This is used in cases in which parts of
# the interface hierarchy are not to be used directly (such as LiteralNode, which is simply a superclass for specific
# types of LiteralNodes).
#
# The immediate superclass may be suffixed by a "+" and a comma-separated list of interface names.  If this occurs, the
# interfaces are extended by interface implementations.  Note that no properties can be conveyed by this functionality;
# the intention is that this feature be used for tagging interfaces.
#
# The format of a line of information is dependent upon the "mode" of the interpreter.  The mode of the interpeter is
# unset each time a class description begins; a mode must be set for a line of information to make sense.  A mode is
# set using a line beginning in '@' (ignoring leading whitespace).  For example, a single line containing "@props"
# causes the following lines to be interpreted in props mode.
#
# Information lines in props mode are read in the following way:
#     * All content after a pipe symbol ('|') is treated as a description of the property (used in comments).
#     * All content up to the first space (ignoring leading whitespace) is treated as the name of the property.
#     * The rest of the line is treated as the property's type.
#
# If the property's name is suffixed by a '*' character, no setter will be generated for it.
#
# The second mode available is docs.  When in docs mode, each line is interpreted as Javadoc commentation for the class
# itself.  Note that each line will be interpreted as HTML by the Javadoc reader.
#
# The third mode is include.  When in include mode, each line is taken to be a filename in the supplements directory.
# Each file is read line by line and scanned for comments on their own line.  Each comment of the form
# /* GEN:foo */ (where foo is any string containing no whitespace) is interpreted rather than processed.  Interpreted
# comments change the behavior of the file inclusion.  Lines which appear after a "start" are copied into the body of
# the file until a "stop" is encountered.  Lines which appear after an "importstart" are copied into the header of the
# file until an "importstop" is encountered.  If an include is specified, it must be present in both the classes and
# ifaces directories, even if one of them is empty.

#######################################################################################################################
# JAVA AST NODES
#######################################################################################################################

!set iPackage=edu.jhu.cs.bsj.compiler.ast.node
!set cPackage=edu.jhu.cs.bsj.compiler.impl.ast.node

### Expression Nodes ##################################################################################################

ArrayAccessNode :: ExpressionNode
    @props
    expression              ExpressionNode                              | the expression identifying the array
    index                   ExpressionNode                              | the index into the array
    @docs
        Represents an array access, as in:
        <pre>
        <i>expression</i>[<i>index</i>]
        </pre>

ArrayInstantiatonNode :: ExpressionNode
    @props
    type                    TypeNode                                    | the type of the elements in the array
    dimensions              ListNode<? extends ExpressionNode>          | the dimensions of the array to create
    @docs
        A node representing the creation of a new array, as in:
        <pre>
        new <i>type</i>[<i>dim</i>]<i>...</i>
        </pre>
        The resulting array contains default values based upon the array's type (0, false, or null).

ArrayInitializerNode :: ExpressionNode
    @props
    type                    TypeNode                                    | the type of the elements in the array
    initializers            ListNode<? extends ExpressionNode>          | the initializers for the array
    @docs
        A node representing the creation of a new array, as in:
        <pre>
        new <i>type</i>[]{<i>initializer...</i>}
        </pre>
        The resulting array contains one element for each initializer expression.

AssignmentNode :: ExpressionNode
    @props
    variable                ExpressionNode                              | the variable to which to assign a value
    operator                AssignmentOperator                          | the assignment operator indicating the operation to perform
    expression              ExpressionNode                              | the expression to use
    @docs
        Represents the assignment of an expression to a variable, as in
        <pre>
        <i>expr op expr</i>
        </pre>
        where <i>op</i> is one of <tt>+=</tt>, <tt>%=</tt>, etc.

BinaryOperatorNode :: ExpressionNode
    @props
    leftOperand             ExpressionNode                              | the left operand of the expression
    rightOperand            ExpressionNode                              | the right operand of the expression
    operator                BinaryOperator                              | the binary operator to apply
    @docs
        Represents the application of a binary operator.

ClassInstantiationNode :: ExpressionNode
    @props
    typeArguments           ListNode<? extends TypeNode>                | the type arguments of the instantiation
    identifier              NameNode                                    | the identifier of the class
    arguments               ListNode<? extends ExpressionNode>          | the arguments to the constructor
    classBody               ClassDeclarationNode                        | the body of the anonymous class
    enclosingExpression     ExpressionNode                              | the expression enclosing the non-static inner class
    @docs
        A node representing the instantiation of a class, as in:
        <pre>
        new <i>type</i>(<i>arg...</i>)
        </pre>

CompoundAssignmentNode :: ExpressionNode
    @props
    expression              ExpressionNode                              | the expression to assign
    variable                NameNode                                    | the variable to which assignment is occurring
    @docs
        Represents a compound assignment node.  A compound assignment node is one which performs an assignment operation
        which implicitly uses the value of the variable to which a value is being assigned, as in:
        <pre>
        <i>variable compoundOp expression</i>
        </pre>
        where <i>compoundOp</i> is one of <tt>+=</tt>, <tt>&=</tt>, etc.

ConditionalExpressionNode :: ExpressionNode
    @props
    condition               ExpressionNode                              | the condition of the expression
    trueExpression          ExpressionNode                              | the value of this expression when the condition is true
    falseExpression         ExpressionNode                              | the value of this expression when the condition is false
    @docs
        Represents a conditional <i>expression</i>, as in:
        <pre>
        <i>condition</i> ? <i>expression</i> : <i>expression</i>
        </pre>

# TODO: how do we want to handle ErroneousNode?

IdentifierNode :: NameNode
    @props
    identifier              String                                      | the identifier contained in this node
    @docs
        A tree node representing a simple identifier, as in:
        <pre>
        <i>name</i>
        </pre>

InstanceOfNode :: ExpressionNode
    @props
    expression              ExpressionNode                              | the expression being evaluated
    type                    TypeNode                                    | the type being checked
    @docs
        Represents the invocation of the <tt>instanceof</tt> operator, as in:
        <pre>
        <i>expression</i> instanceof <i>type</i>
        </pre>

LiteralNode<T>* :: ExpressionNode
    @props
    value                   T                                           | the literal value for this node
    @docs
        A superclass for all types of literal nodes.

MemberSelectNode :: ExpressionNode
    @props
    expression              ExpressionNode                              | the expression from which to select
    identifier              IdentifierNode                              | the identifier to select
    @docs
        A node representing member selection, as in:
        <pre>
        <i>expr<i> . <i>identifier</i>
        </pre>
        Member select nodes are used to select members from expressions.  They are not used for chains of identifier
        names as in package imports.  See {@link QualifiedNameNode}.

MethodInvocationNode :: ExpressionNode
    @props
    methodSelect            NameNode                                    | the selection obtaining the method to invoke
    arguments               ListNode<? extends ExpressionNode>          | the arguments to pass to the method
    typeArguments           ListNode<? extends TypeNode>                | the type arguments for the method
    @docs
        A node representing method invocation, as in:
        <pre>
        <i>expr</i>.&lt;<i>typeArgs</i>&gt;<i>identifier</i>(<i>arg...</i>)
        </pre>

NameNode* :: ExpressionNode
    @docs
        A common supertype to nodes which represent a name.

QualifiedNameNode :: NameNode
    @props
    name                    NameNode                                    | the name to qualify
    identifier              IdentifierNode                              | the identifier to use
    @docs
        A node representing a name qualification, as in
        <pre>
        <i>name<i> . <i>identifier</i>
        </pre>
        QualifiedNameNodes are used to identify classes in package imports and other identifier chains.  They are not
        used to select members from expressions.  See {@link MemberSelectNode}.

TypeCastNode :: ExpressionNode
    @props
    expression              ExpressionNode                              | the expression to cast
    type                    TypeNode                                    | the type to which to cast
    @docs
        A node for typecast expressions, as in:
        <pre>
        (<i>type</i>) <i>expr</i>
        </pre>

UnaryOperatorNode :: ExpressionNode
    @props
    expression              ExpressionNode                              | the expression on which to operate
    operator                UnaryOperator                               | the operator to apply
    @docs
        A node for unary expressions, such as:
        <pre>
        ~0
        </pre>
        or
        <pre>
        x++
        </pre>

### Statement Nodes ###################################################################################################

AssertStatementNode :: StatementNode
    @props
    testExpression          ExpressionNode                              | the assertion's test expression
    messageExpression       ExpressionNode                              | the assertion's message expression
    @docs
        Represents an assert statement, as in
        <pre>
            assert <i>expr</i>;
        </pre>
        or
        <pre>
            assert <i>expr</i> : <i>expr</i>;
        </pre>

BlockStatementNode :: StatementNode
    @props
    statements              ListNode<? extends StatementNode>           | the statements contained in this block statement
    @docs
        Represents a block of statements, as in
        <pre>
        {
            <i>statement</i>
            <i>...</i>
        }
        </pre>
    
BreakNode :: StatementNode
    @props
    label                   IdentifierNode                              | the break label
    @docs
        A node representing break statements, as in:
        <pre>
            break <i>label</i>;
        </pre>

ContinueNode :: StatementNode
    @props
    label                   IdentifierNode                              | the continue label
    @docs
        A node representing continue statements, as in:
        <pre>
            continue <i>label</i>;
        </pre>

DoWhileLoopNode :: StatementNode
    @props
    condition               ExpressionNode                              | the loop's condition
    statement               StatementNode                               | the loop's statement
    @docs
        A node representing a do-while loop, as in:
        <pre>
        do <i>body</i> while (<i>condition</i>);
        </pre>

EnhancedForLoopNode :: StatementNode
    @props
    variable                VariableNode                                | the iterator variable
    expression              ExpressionNode                              | the loop's iterable expression
    statement               StatementNode                               | the loop's statement
    @docs
        A node representing a for-each loop, as in:
        <pre>
        for (<i>variable</i> : <i>expression</i>)
            <i>body</i>
        </pre>

ExpressionStatementNode :: StatementNode
    @props
    expression              ExpressionNode                              | this statement's expression
    @docs
        A node representing an expression statement.  This allows any expression to be used as a statement and its
        value discarded.
    
ForLoopNode :: StatementNode
    @props
    initializer             ListNode<? extends StatementNode>           | the iterator variable
    update                  ListNode<? extends ExpressionStatementNode> | the loop's update operation
    condition               ExpressionNode                              | the loop's termination condition
    statement               StatementNode                               | the loop's statement
    @docs
        A node representing a for-loop, as in:
        <pre>
        for (<i>initializers</i>; <i>condition</i>; <i>updaters</i>)
            <i>body</i>
        </pre>
    
IfNode :: StatementNode
    @props
    condition               ExpressionNode                              | the condition
    thenStatement           StatementNode                               | the then branch's statement
    elseStatement           StatementNode                               | the else branch's statement
    @docs
        A node representing an if-then-else statement, as in:
        <pre>
        if (<i>condition</i>) then <i>statement</i> else <i>statement</i>
        </pre>

InlineTypeDeclarationNode :: StatementNode
    @props
    declaration             InlineTypeDeclarable                        | the type declaration
    @docs
        A node representing an inline type declaration.  This is used to allow classes and enums to be declared
        within a method body or similar environment.
    
LabeledStatementNode :: StatementNode
    @props
    label                   IdentifierNode                              | the statement's label
    statement               StatementNode                               | the statement being labeled
    @docs
        A node representing labeled statements, as in:
        <pre>
        <i>identifier</i>: <i>statement</i>
        </pre>

ReturnNode :: StatementNode
    @props
    expression              ExpressionNode                              | the expression to return
    @docs
        A node representing a return statement, as in;
        <pre>return <i>expr</i>;</pre>
        or
        <pre>return;</pre>
        For void return statements, the <tt>expression</tt> is <tt>null</tt>.
# TODO: should we be using null object for things like this?
    
SwitchNode :: StatementNode
    @props
    expression              ExpressionNode                              | the expression over which to switch
    cases                   ListNode<? extends CaseNode>                | the cases in this switch
    @docs
        A node to represent switch statements, as in:
        <pre>
        switch (<i>expr</i>) {
            case <i>value</i>:
            ...
        }
        </pre>

SynchronizedNode :: StatementNode
    @props
    expression              ExpressionNode                              | the synchronization expression
    block                   BlockStatementNode                          | the block of statements to synchronize
    @docs
        A node to represent synchronization statements, as in:
        <pre>
        synchronized (<i>expr</i>) {
            ...
        }
        </pre>

ThrowNode :: StatementNode
    @props
    expression              ExpressionNode                              | the Throwable to throw
    @docs
        A node to represent throw statements, as in:
        <pre>
        throw <i>expr</i>;
        </pre>

TryNode :: StatementNode
    @props
    block                   BlockStatementNode                          | the block in which to try
    catches                 ListNode<? extends CatchNode>               | the catch conditions
    finallyBlock            BlockStatementNode                          | the finally block
    @docs
        A node to represent a try-catch block, as in:
        <pre>
        try <i>block</i>
        catch (<i>type name</i>) <i>block</i>
        </pre>
        or
        <pre>
        try <i>block</i>
        catch (<i>type name</i>) <i>block</i>
        catch (<i>type name</i>) <i>block</i>
        finally <i>block</i>
        </pre>

VariableDeclarationNode :: StatementNode
    @props
    modifiers               ModifiersNode                               | the modifiers for this variable
    declarators             ListNode<VariableDeclaratorNode>            | the variable declarators for this node
    @docs
        A node for the declaration of a variable, as in:
            <pre>
            <i>type identifier</i>;
            </pre>
        or
            <pre>
            <i>type identifier</i> = <i>expression</i>;
            </pre>
        or
            <pre>
            <i>type identifier</i> = <i>expression</i>, <i>identifier</i> = <i>expression</i>, ...;

VariableDeclaratorNode :: StatementNode
    @props
    type                    TypeNode                                    | the type of this variable
    name                    IdentifierNode                              | the name of this variable
    initializer             ExpressionNode                              | the initializer to use
    @docs
        Represents a declarator for a variable declaration.  For example, in
        <pre>int x = 5, y;</pre>
        this node either represents
        <pre>x = 5</pre>
        or
        <pre>y</pre>
        .  Note that variable multi-declaration syntax allows different types, as in
        <pre>int x = 5, y[] = new int[2];</pre>
        Hence, type exists on this node instead of its parent.
        
VoidStatementNode :: StatementNode
    @docs
        A node representing a void statement, as in
        <pre>;</pre>        

WhileLoopNode :: StatementNode
    @props
    condition               ExpressionNode                              | the loop's condition
    statement               StatementNode                               | the loop's statement
    @docs
        A node for a while loop, as in:
        <pre>
        while (<i>condition</i>)
            statement
        </pre>

### Type Nodes ########################################################################################################

ArrayTypeNode :: TypeNode + TypeArgument
    @props
    type                    TypeNode                                    | the element type of the array
    @docs
        Represents an array type.

DeclaredTypeNode :: TypeNode + TypeArgument, BoundType, ParameterizableType
    @props
    name                    IdentifierNode                              | the identifier naming this type
    @docs
        A node expressing a declared type.  Declared types encompass classes, interfaces, enums, and annotations.
        Anonymous classes and other such constructs are included as well.

ParameterizedTypeNode :: TypeNode + TypeArgument, BoundType
    @props
    baseType                ParameterizableType                         | the base to parameterize
    typeArguments           ListNode<? extends TypeArgument>            | the parameterized type arguments
    @docs
        A node representing a type parameterization as in:
        <pre>
        <i>type</i> &lt;<i>arg...</i>&gt;
        </pre>

PrimitiveTypeNode :: TypeNode
    @props
    primitiveType           PrimitiveType                               | the primitive type being represented
    @docs
        A node representing a primitive type.

TypeSelectNode :: TypeNode + TypeArgument, BoundType, ParameterizableType
    @props
    base                    BoundType                                   | the base type from which to select
    select                  DeclaredTypeNode                            | the selected type from the base type
    @docs
        A node representing a type selection, as in:
        <pre>
        <i>type</i> . <i>type</i>
        </pre>

VoidTypeNode :: TypeNode
    @docs
        A node representing the void type.  This is used, for example, in method return values.

### Literal Nodes #####################################################################################################

BooleanLiteralNode :: LiteralNode<Boolean>
    @docs
        A node representing a boolean literal.

CharLiteralNode :: LiteralNode<Character>
    @docs
        A node representing a character literal.

DoubleLiteralNode :: LiteralNode<Double>
    @docs
        A node representing a double literal.

FloatLiteralNode :: LiteralNode<Float>
    @docs
        A node representing a float literal.

IntLiteralNode :: LiteralNode<Integer>
    @docs
        A node representing an int literal.

LongLiteralNode :: LiteralNode<Long>
    @docs
        A node representing a long literal.

StringLiteralNode :: LiteralNode<String>
    @docs
        A node representing a String literal.
        
### Member Nodes ######################################################################################################

AnnotationMethodDeclarationNode :: Node + AnnotationMember
    @props
    modifiers               ModifiersNode                               | the modifiers for this annotation method
    type                    TypeNode                                    | the return type of this annotation method
    identifier              IdentifierNode                              | this annotation method's name
    defaultValue            ExpressionNode                              | the default value for this method
    @docs
        A node representing an annotation method declaration, as in:
        <pre>
            <i>modifiers type identifier</i> () default <i>defaultValue</i>;
        </pre>

ConstructorDeclarationNode :: Node + ClassMember
    @props
    body                    ConstructorBodyNode                         | the body of this constructor
    modifiers               ModifiersNode                               | the modifiers for this constructor
    parameters              ListNode<? extends VariableNode>            | the parameters declared by this constructor
    varargParameter         VariableNode                                | the vararg parameter declared by this method
    throwTypes              ListNode<? extends DeclaredTypeNode>        | the types of exceptions thrown by this constructor
    typeParameters          ListNode<? extends TypeParameterNode>       | this constructor's applicable type parameters
    @docs
        A node representing a constructor declaration, as in:
        <pre>
            <i>modifiers typeParams typeName</i>(<i>parameter...</i>) throws <i>expr...</i>
                <i>body</i>
        </pre>
        See {@link MethodDeclarationNode} for more information.

EnumConstantDeclarationNode :: Node
    @props
    annotations             ListNode<? extends AnnotationNode>          | the annotations on this constant
    identifier              IdentifierNode                              | the name of this constant
    arguments               ListNode<? extends ExpressionNode>          | the arguments to the enum constructor
    body                    ClassBodyNode                               | the body used to anonymously subclass the constant
    @docs
        A node representing an enum constant.  While enum constants typically consist of a single name, many optional
        extensions exist.  Enum constants are distinguished from normal variables for purposes of reverse-generating
        source.

FieldDeclarationNode :: Node + ClassMember, InterfaceMember, AnnotationMember
    @props
    modifiers               ModifiersNode                               | the modifiers for this field
    declarators             ListNode<VariableDeclaratorNode>            | the variable declarators for this node
    @docs
        A node representing a field declaration.  Constants are represented by this node as well.

InitializerDeclarationNode :: Node + ClassMember
    @props
    staticInitializer       boolean                                     | whether or not the initializer is static
    body                    BlockStatementNode                          | the body of the initializer

MethodDeclarationNode :: Node + ClassMember, InterfaceMember
    @props
    body                    BlockStatementNode                          | the body of this method
    modifiers               ModifiersNode                               | the modifiers for this method
    name                    IdentifierNode                              | this method's name
    parameters              ListNode<? extends VariableNode>            | the parameters declared by this method
    varargParameter         VariableNode                                | the vararg parameter declared by this method
    returnType              TypeNode                                    | the type of value returned
    throwTypes              ListNode<? extends DeclaredTypeNode>        | the types of exceptions thrown by this method
    typeParameters          ListNode<? extends TypeParameterNode>       | this method's applicable type parameters
    @docs
        A node representing a method declaration, as in:
        <pre>
            <i>modifiers typeParams type name</i>(<i>parameter...</i>) throws <i>expr...</i>
                <i>body</i>
        </pre>
        Note that the vararg parameter is used in cases where a variable argument is used, such as in
        <pre>
            public void foo(String... vararg)
        </pre>
        The type on the <tt>varargParameter</tt> node should be <tt>String</tt> in the above case (and <i>not</i>
        <tt>String[]</tt>).

### Type Body Nodes ####################################################################################################

AnnotationBodyNode :: Node
    @props
    members             ListNode<? extends AnnotationMember>            | the members of this annotation body
    @docs
        Represents the body of an annotation declaration.

ClassBodyNode :: Node
    @props
    members             ListNode<? extends ClassMember>                 | the members of this class body
    @docs
        Represents the body of a class declaration.

EnumBodyNode :: Node
    @props
    constants           ListNode<? extends EnumConstantDeclarationNode> | the enumeration constants
    members             ListNode<? extends ClassMember>                 | the members of the class body part
    @docs
        Represents the body of an enum declaration.

InterfaceBodyNode :: Node
    @props
    members             ListNode<? extends InterfaceMember>             | the members of this interface body
    @docs
        Represents the body of an interface declaration.

### Type Declaration Nodes ############################################################################################

AnnotationDeclarationNode :: NamedTypeDeclarationNode
    @props
    body                    AnnotationBodyNode                          | this annotation's body
    @docs
        Represents the declaration of an annotation, as in:
        <pre>
        <i>modifiers</i> @interface <i>name</i>
        {
            <i>member</i>
            ...
        }
        </pre>

ClassDeclarationNode :: NamedTypeDeclarationNode + InlineTypeDeclarable
    @props
    extendsClause           TypeNode                                    | the extends clause
    implementsClause        ListNode<? extends TypeNode>                | the implements clause
    body                    ClassBodyNode                               | the body of this class
    typeParameters          ListNode<? extends TypeParameterNode>       | this class's type parameters
    @docs
        Represents the declaration of a class, as in:
        <pre>
        <i>modifiers<i> class <i>name</i>&lt;<i>typeParam...</i>&gt; extends <i>type</i> implements <i>type...</i>
        {
            <i>member</i>
            <i>...</i>
        }
        </pre>
        
EnumDeclarationNode :: NamedTypeDeclarationNode + InlineTypeDeclarable
    @props
    implementsClause        ListNode<? extends TypeNode>                | the implements clause
    body                    EnumBodyNode                                | this enum's body
    @docs
        Represents the declaration of a class, as in:
        <pre>
        <i>modifiers<i> enum <i>name</i> implements <i>type...</i>
        {
            <i>member</i>
            <i>...</i>
        }
        </pre>

InterfaceDeclarationNode :: NamedTypeDeclarationNode
    @props
    extendsClause           ListNode<? extends TypeNode>                | the extends clause
    body                    InterfaceBodyNode                           | this interface's body
    typeParameters          ListNode<? extends TypeParameterNode>       | this class's type parameters
    @docs
        Represents the declaration of an interface, as in:
        <pre>
        <i>modifiers<i> interface <i>name</i>&lt;<i>typeParam...</i>&gt; extends <i>type...</i>
        {
            <i>member</i>
            <i>...</i>
        }
        </pre>

NamedTypeDeclarationNode* :: TypeDeclarationNode
    @props
    simpleName              IdentifierNode                              | the name of this declared type
    modifiers               ModifiersNode                               | the modifiers for this declared type
    @docs
        Acts as a superclass for all named type declarations.

TypeDeclarationNode* :: Node + ClassMember, InterfaceMember, AnnotationMember
    @docs
        Acts as a superclass for all type declarations.

VoidTypeDeclarationNode :: TypeDeclarationNode
    @docs
        Represents the void declaration (a single semi-colon).

### Annotation Nodes ##################################################################################################

AnnotationAnnotationValueNode :: AnnotationValueNode
    @props
    annotation              AnnotationNode                              | the annotation
    @docs
        A value in an annotation which is another annotation.  This node is used for complex annotations, such as
        <pre>@Foo(a=@Bar)</pre>
        In the above snippet, this node would represent the
        <pre>@Bar</pre>
        portion.

AnnotationArrayValueNode :: AnnotationValueNode
    @props
    values                  ListNode<? extends AnnotationValueNode>     | the array values
    @docs
        A value in an annotation representing an array.  This node is distinct from the {@link ArrayInitializerNode}
        because it allows annotations (by way of {@link AnnotationAnnotationValueNode}) as well as expressions.

# TODO: is there a nice way for us to type-encode that this expression may not be an assignment expression?
AnnotationExpressionValueNode :: AnnotationValueNode
    @props
    expression              ExpressionNode                              | the expression
    @docs
        A value in an annotation which is an expression.  This value may not be an assignment expression.

AnnotationNode* :: Node
    @props
    annotationType          DeclaredTypeNode                            | the annotation type
    @docs
        Acts as a base class for annotation nodes.  Subclasses distinguish between the different types of annotation
        sugar.

AnnotationElementNode :: Node
    @props
    identifier              IdentifierNode                              | the identifier
    value                   AnnotationValueNode                         | the element's value
    @docs
        Represents an annotation element, as in
        <pre>
        <i>ident</i>=<i>value</i>
        </pre>

AnnotationValueNode* :: Node
    @docs
        Acts as a common base class for all annotation values.

NormalAnnotationNode :: AnnotationNode
    @props
    arguments               ListNode<? extends AnnotationElementNode>   | the arguments
    @docs
        Represents the usage of an annotation, as in:
        <pre>@<i>type</i></pre>
        or
        <pre>@<i>type</i>(<i>key</i>=<i>value</i>,...)</pre>
        Note that this node does not handle the single element annotation format (<pre>@Foo("bar")</pre>).  That is
        handled by the {@link SingleElementAnnotationNode} class.

SingleElementAnnotationNode :: AnnotationNode
    @props
    value                   AnnotationValueNode                         | the value of the "value" element
    @docs
        Represents a single element annotation, as in:
        <pre>@<i>type</i>(<i>value</i>)</pre>

### Base Nodes ########################################################################################################

AlternateConstructorInvocationNode :: ConstructorInvocationNode
    @docs
        Represents an alternate constructor invocation, as in
        <pre>
        this("foo")
        </pre>
        Note that this only applies to <i>alternate</i> constructor invocations (those using the <tt>this</tt> keyword).
        For superclass constructor invocations, see {@link SuperclassConstructorInvocationNode}.

CaseNode :: Node
    @props
    expression              ExpressionNode                              | the expression used in this case label
    statements              ListNode<? extends StatementNode>           | the statements to execute in this case node
    @docs
        A node representing a switch's case block, as in:
        <pre>
        case <i>expression</i>:
            <i>statement</i>
            <i>...</i>
        </pre>
        or
        <pre>
        default:
            <i>statement</i>
            <i>...</i>
        </pre>
        If the switch label is <tt>default</tt>, <tt>expression</tt> is <tt>null</tt>. 

CatchNode :: Node
    @props
    block                   BlockStatementNode                          | the block to execute when this catch occurs
    parameter               VariableNode                                | this catch block's exception variable
    @docs
        A node representing a catch block, as in
        <pre>
        catch (<i>type identifier</i>)
            <i>block</i>
        </pre>

CompilationUnitNode :: Node
    @props
    packageDeclaration      PackageDeclarationNode                      | the package declaration for this unit
    imports                 ListNode<? extends ImportNode>              | the imports used in this unit
    typeDecls               ListNode<? extends TypeDeclarationNode>     | the type declarations of this unit
    @docs
        Represents a BSJ compilation unit.
    # TODO: do we want sourceFile of type JavaFileObject here or something similar?

ConstructorBodyNode :: Node
    @props
    constructorInvocation   ConstructorInvocationNode                   | the (nullable) constructor invocation
    statements              ListNode<? extends StatementNode>           | the statements contained in this constructor
    @docs
        Represents a constructor body.  For example, in
        <pre>
        public MyClass()
        {
            super();
            this.foo = 0;
        }
        </pre>
        this node would represent all but the first line.  Observe that this structure enforces the Java language rule
        that there be exactly one explicit constructor invocation and that it appears at the top of the constructor
        body.

# TODO: the language specification says that the type nodes in the list can't be wild - can we type-encode this?
ConstructorInvocationNode* :: Node
    @props
    arguments               ListNode<? extends ExpressionNode>          | the arguments to pass to the method
    typeArguments           ListNode<? extends TypeNode>                | the type arguments for the method
    @docs
        This class is a common superclass to both types of explicit constructor invocations: alternate constructor
        invocations (those using the <tt>this</tt> keyword) and superclass constructor invocations (those using the
        <tt>super</tt> keyword).  This distinction is made because, despite their similarities in use and syntax, the
        language specification treats these two entities as distinct (and there are some corner cases for the superclass
        constructor syntax which are best contained

ExpressionNode* :: Node
    @docs
        This class is a common superclass of all BSJ AST nodes representing expressions.

ImportNode :: Node
    @props
    qualifiedIdentifier     NameNode                                    | the identifier to import
    staticImport            boolean                                     | the static-ness of the import
    @docs
        A node representing a compilation unit import statement.

!set stopGen=cons

ListNode<T extends Node> :: Node
    @props
    children*               List<? extends T>                           | the list of children  
    @docs
        Represents a list of nodes.  Nodes do not simply have lists as properties as the ListNode allows additional
        information to be tracked as necessary.
    @include
        ListNode.java

!set stopGen=

ModifiersNode :: Node
    @props
    annotations             ListNode<? extends AnnotationNode>          | the annotations modifying the subject
    flags                   Set<Modifier>                               | the modifiers set on the subject
    @docs
        A node representing the modifiers applied to another node.  Modifiers may include flags (such as <tt>final</tt>
        or <tt>strictfp</tt>) and annotations (such as <tt>@Override</tt>).
    
Node*
    @props
    @include
        Node.java
    @docs
        The parent class for all BSJ AST nodes.

PackageDeclarationNode :: Node
    @props
    name                    QualifiedNameNode                           | the qualified name indicating the package
    annotations             ListNode<? extends AnnotationNode>          | the annotations on the package declaration
    @docs
        A node representing a package declaration, as in
        <pre>
            package <i>packageName</i>;
        </pre>
        or
        <pre>
            <i>annotations</i>
            package <i>packageName</i>;
        </pre>

SuperclassConstructorInvocationNode :: ConstructorInvocationNode
    @props
    qualifyingExpression    ExpressionNode                              | the qualifying expression for the enclosing object
    @docs
        Represents an alternate constructor invocation, as in
        <pre>
        super("foo")
        </pre>
        or in the rarer syntax
        <pre>
        (new Foo()).super(0)
        </pre>
        .  Note that this only applies to <i>superclass</i> constructor invocations (those using the <tt>super</tt>
        keyword).  For alternate constructor invocations, see {@link AlternateConstructorInvocationNode}.

VariableNode :: Node
    @props
    modifiers               ModifiersNode                               | the modifiers of this parameter
    type                    TypeNode                                    | the type of the parameter
    name                    IdentifierNode                              | the name of the parameter
    @docs
        A node describing a variable, as in:
            <pre>
            <i>type identifier</i>
            </pre>

StatementNode* :: Node
    @docs
        Common superclass for statements.

TypeNode* :: Node
    @docs
        Common superclass for types.

TypeParameterNode :: Node
    @props
    name                    IdentifierNode                              | the base type name for the parameter
    bounds                  ListNode<? extends BoundType>               | the bounds over the base type
    @docs
        A node for type parameters, as in:
        <pre>
        <i>name</i>
        </pre>
        or
        <pre>
        <i>name</i> extends <i>type</i>
        </pre>
        or
        <pre>
        <i>name</i> extends <i>type</i> &amp; <i>type...</i>
        </pre>

WildcardTypeNode :: Node + TypeArgument
    @props
    bound                   TypeNode                                    | the wildcard's bound
    upperBound              boolean                                     | whether or not the wildcard's bound is an upper (<tt>extends</tt>) bound
    @docs
        A nore for wildcard type parameters, as in:
        <pre>
        ? extends <i>type</i>
        </pre>
        (in which case <tt>bound</tt> is non-<tt>null</tt> and <tt>upperBound</tt> is <tt>true</tt>) or
        <pre>
        ? super <i>type</i>
        </pre>
        (in which case <tt>bound</tt> is non-<tt>null</tt> and <tt>upperBound</tt> is <tt>false</tt>) or
        <pre>
        ?
        </pre>
        (in which case <tt>bound</tt> is <tt>null</tt>).

#######################################################################################################################
# BSJ AST NODES
#######################################################################################################################

!set iPackage=edu.jhu.cs.bsj.compiler.ast.node.meta
!set cPackage=edu.jhu.cs.bsj.compiler.impl.ast.node.meta

# TODO

CodeLiteralNode :: LiteralNode<Node>
    @docs
        A node representing a code literal.
