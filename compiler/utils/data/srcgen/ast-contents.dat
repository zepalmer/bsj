# This file is used to describe the interfaces and classes that are used by the BSJ parser to represent ASTs.  It is
# used to generate corresponding source code manually.
#
# The format of this file is very sloppy as it is meant only to save frequent maintenance.  Any content appearing after
# a '#' on a line is a comment.  Otherwise, content may be a class description or an operation description.  Class
# descriptions are separated by line breaks.  The first line of a class description indicates the class's name and
# immediate superclass.  Each following line up until a blank line is treated as information about the class
# description.
#
# An operation description starts with a '!' character.  The syntax of an operation depends on which operation is being
# invoked.  Valid operations are:
#
#     * !set: Sets a variable for the generator.  All class descriptions which appear after this operation will be
#             affected accordingly.  The syntax is "!set name=value".  Valid names are:
#         + iPackage:     Changes the package for generated interface files.
#         + cPackage:     Changes the package for generated backing class files.
#         + stopGen:      A comma-separated list of items to avoid generating.  The items are generated anyway, but
#                         within a comment.  The legal items are:
#             - cons:     Prevents a concrete class's constructor from being generated.
#             - children: Prevents a class's getChildObjects method from being generated.
#
# The class's name and immediate superclass are separated by "::".  Additionally, the class's name may be suffixed in a
# '*' character.  If this is the case, no concrete implementation is expected.  This is used in cases in which parts of
# the interface hierarchy are not to be used directly (such as LiteralNode, which is simply a superclass for specific
# types of LiteralNodes).  The class name may instead be suffixed by a + character; in this case, the class itself is
# not created; only the interface is generated.  This is particularly useful for the creation of tagging interfaces.
#
# The immediate superclass may be suffixed by a "+" and a comma-separated list of interface names.  If this occurs, the
# interfaces are extended by interface implementations.  Note that no properties can be conveyed by this functionality;
# the intention is that this feature be used for tagging interfaces.
#
# The format of a line of information is dependent upon the "mode" of the interpreter.  The mode of the interpeter is
# unset each time a class description begins; a mode must be set for a line of information to make sense.  A mode is
# set using a line beginning in '@' (ignoring leading whitespace).  For example, a single line containing "@props"
# causes the following lines to be interpreted in props mode.
#
# Information lines in props mode are read in the following way:
#     * All content after a pipe symbol ('|') is treated as a description of the property (used in comments).
#     * All content up to the first space (ignoring leading whitespace) is treated as the name of the property.
#     * The rest of the line is treated as the property's type.
#
# If the property's name is suffixed by a '*' character, no setter will be generated for it.
#
# The second mode available is docs.  When in docs mode, each line is interpreted as Javadoc commentation for the class
# itself.  Note that each line will be interpreted as HTML by the Javadoc reader.
#
# The third mode is include.  When in include mode, each line is taken to be a filename in the supplements directory.
# Each file is read line by line and scanned for comments on their own line.  Each comment of the form
# /* GEN:foo */ (where foo is any string containing no whitespace) is interpreted rather than processed.  Interpreted
# comments change the behavior of the file inclusion.  Lines which appear after a "start" are copied into the body of
# the file until a "stop" is encountered.  Lines which appear after an "importstart" are copied into the header of the
# file until an "importstop" is encountered.  If an include is specified, it must be present in both the classes and
# ifaces directories, even if one of them is empty.

#######################################################################################################################
# JAVA AST NODES
#######################################################################################################################

!set iPackage=edu.jhu.cs.bsj.compiler.ast.node
!set cPackage=edu.jhu.cs.bsj.compiler.impl.ast.node

### Tagging Interfaces ################################################################################################

# TODO: this is now redundant since our AST represents single expression names as FieldAccessByNameNodes.
ArrayIndexableNode+ :: Node + NonAssignmentExpressionNode
    @docs
        This tagging interface is used to denote AST nodes which can be used as array reference expressions inside of
        an array access node.
        
AnnotationMemberNode+ :: Node
	@docs
		This tagging interface is used to denote AST nodes which can be used as members of an annotation declaration's
		body.

AnnotationValueNode+ :: Node
    @docs
        This tagging interface is used to denote AST nodes which represent annotation values.

AnonymousClassMemberNode+ :: Node + ClassMemberNode
	@docs
		This tagging interface is used to denote AST nodes which can be used as members of an anonymous class's body.
		Since the set of declarations which may appear in an anonymous class is a subset of that which may appear in a
		named class, this type is a subtype of {@link ClassMember}.
 		
BaseTypeNode+ :: Node
	@docs
		This tagging interface is used to denote AST nodes which can be used as array base types.
		
ClassMemberNode+ :: Node
	@docs
		This tagging interface is used to denote AST nodes which can be used as members of a class declaration's body.
		
DeclaredTypeNode+ :: Node + ReferenceTypeNode, BaseTypeNode
    @docs
        A node representing any declared type.  In the BSJ API, a "declared type" refers to any type which has been
        created by a declaration statement.  Arrays and primitives are not declared types because they are not declared.

ExpressionNode+ :: Node + VariableInitializerNode
    @docs
        This tagging interface is used to denote BSJ AST nodes which represent expressions.

FieldAccessNode+ :: Node + RestrictedPrimaryExpressionNode
    @docs
        This tagging interface is used to denote BSJ AST nodes which represent field access.

ForInitializerNode+ :: Node
    @docs
        This tagging interface is used to denote AST nodes which are used as standard for-loop initializers.  It exists
        to allow the two different types of for loop initializers to be used coherently.

ImportNode+ :: Node
    @docs
        This tagging interface is used to denote AST nodes which represent import statements.

InlineTypeDeclarableNode+ :: Node + TypeDeclarationNode
	@docs
		This tagging interface is used to denote AST nodes which represent type declarations and can be declared inline
		as a statement.
		
InterfaceMemberNode+ :: Node
	@docs
		This tagging interface is used to denote AST nodes which can be used as members of an interface declaration's
		body.
		
LiteralizableTypeNode+ :: Node + TypeNode
    @docs
        This tagging interface is used to denote AST nodes which refer to a type which can be used to define a class
        literal (such as <tt>String.class</tt>, <tt>int.class</tt>, or <tt>String[].class</tt>).  Note that
        parameterized types may not be used to create literals; that is, <tt>Set&lt;String&gt;.class</tt> is illegal.

NonAssignmentExpressionNode+ :: Node + ExpressionNode
    @docs
        This tagging interface describes expressions which are not assignment expressions.  In some contexts, assignment
        expressions are not permitted (such as in the initializers of annotation values).

PrimaryExpressionNode+ :: Node + NonAssignmentExpressionNode
    @docs
        A tagging interface for all nodes considered "primary expressions" by the Java Language Specification.  Primary
        expressions include the basic building blocks of more complex expressions.

ReferenceTypeNode+ :: Node + TypeNode, TypeArgumentNode
    @docs
        A node representing a reference type.  A reference type in Java is any non-primitive type.

RestrictedPrimaryExpressionNode+ :: Node + PrimaryExpressionNode, ArrayIndexableNode
    @docs
        A tagging interface for restricted primary expressions.  This maps to the <i>PrimaryNoNewArray</i> parse target
        in the JLS.

StatementNode+ :: Node
    @docs
        This tagging interface is used to denote AST nodes which represent statements.
		
TypeArgumentNode+ :: Node
	@docs
		This tagging interface is used to denote AST nodes which can be used as type arguments.

TypeDeclarationNode+ :: Node + ClassMemberNode, InterfaceMemberNode, AnnotationMemberNode, AnonymousClassMemberNode
    @docs
        This tagging interface is used to denoate AST nodes which declare types.

TypeNode+ :: Node
    @docs
        This tagging interface is used to denote AST nodes which refer to types.

VariableInitializerNode+ :: Node
    @docs
        This tagging interface is used to denote AST nodes which represent a variable initialization using either an
        expression or an array initializer.          
        
### Naming Nodes ######################################################################################################

IdentifierNode :: Node
    @props
    identifier              String                                      | the identifier contained in this node
    @docs
        A tree node representing a simple identifier, as in:
        <pre>
        <i>ident</i>
        </pre>

NameNode* :: Node
    @props
    category*               NameCategory                                | the category for this name
    @docs
        A common supertype for all nodes representing a name.  In Java, a name is either a simple name (a single
        identifier) or a qualified name (a name, a dot, and an identifier).  The meaning of a name is context-sensitive
        and is partially dependent upon type information; therefore, this node maintains information about the facts
        currently known about this name.
        <p/>
        Note that some identifiers are not used as names; as a result, not all identifiers are children of this class
        or one of its subclasses.  Examples of such cases include variable and type declarations, where the identifier
        is not technically a name because it is being used to create a name which does not exist.  For more information,
        please see the Java Language Specification v3.0 &#167;6.
    @include
        NameNode.java

QualifiedNameNode :: NameNode
    @props
    base                    NameNode                                    | the name being qualified
    identifier              IdentifierNode                              | the identifier used to qualify the base name
    @docs
        Represents a qualified name, as in
        <pre>
        <i>name.ident</i>
        </pre>

SimpleNameNode :: NameNode
    @props
    identifier              IdentifierNode                              | the identifier used as a simple name
    @docs
        Represents a simple name, as in
        <pre>
        <i>name</i>
        </pre>

### Expression Nodes ##################################################################################################

ArrayAccessNode :: Node + RestrictedPrimaryExpressionNode
    @props
    arrayExpression         ArrayIndexableNode                          | the expression identifying the array
    indexExpression         ExpressionNode                              | the index into the array
    @docs
        Represents an array access, as in:
        <pre>
        <i>expression</i>[<i>index</i>]
        </pre>
        
ArrayCreationNode* :: Node + PrimaryExpressionNode
	@props
	baseType				BaseTypeNode								| the base type for this array
	arrayLevels				int											| the number of uninitialized levels for this array
	@docs
		Represents the creation of an array, including both instantiation and initialization.
	
ArrayInitializerCreationNode :: ArrayCreationNode
	@props
	initializer				ArrayInitializerNode						| the initializer for this array
	@docs
		Represents the creation of an array with initializer, as in
		<pre>
		new <i>type</i> []... {<i>initializer</i>,...}
		</pre>
		Levels for this array creator refer to square brace pairs,
		for example <code>new int[][][]</code> would have three levels.

ArrayInstantiatorCreationNode :: ArrayCreationNode
	@props
	dimExpressions			ListNode<ExpressionNode>			        | the dimension expressions for this array
	@docs
		Represents the creation of an array with instantiator, as in
		<pre>
		new <i>type</i> [<i>expression</i>]... []...
		</pre>
		Levels for this array creator refer to square braces without initializers,
		for example <code>new int[2][][]</code> would have two levels.
			
AssignmentNode :: Node + ExpressionNode
    @props
    variable                ExpressionNode                              | the variable to which to assign a value
    operator                AssignmentOperator                          | the assignment operator indicating the operation to perform
    expression              ExpressionNode                              | the expression to use
    @docs
        Represents the assignment of an expression to a variable, as in
        <pre>
        <i>expr op expr</i>
        </pre>
        where <i>op</i> is one of <tt>=</tt>, <tt>+=</tt>, <tt>%=</tt>, etc.

BinaryOperatorNode :: Node + NonAssignmentExpressionNode
    @props
    leftOperand             ExpressionNode                              | the left operand of the expression
    rightOperand            ExpressionNode                              | the right operand of the expression
    operator                BinaryOperator                              | the binary operator to apply
    @docs
        Represents the application of a binary operator.

ClassInstantiationNode* :: Node + RestrictedPrimaryExpressionNode
    @props
    constructorTypeArguments ListNode<TypeArgumentNode>                 | the type arguments for the constructor
    arguments               ListNode<ExpressionNode>                    | the arguments to the constructor
    body                    AnonymousClassBodyNode                      | the body of the anonymous class
    @docs
        Acts as a parent to class instantiation nodes. 

ConditionalExpressionNode :: Node + NonAssignmentExpressionNode
    @props
    condition               ExpressionNode                              | the condition of the expression
    trueExpression          ExpressionNode                              | the value of this expression when the condition is true
    falseExpression         ExpressionNode                              | the value of this expression when the condition is false
    @docs
        Represents a conditional <i>expression</i>, as in:
        <pre>
        <i>condition</i> ? <i>expression</i> : <i>expression</i>
        </pre>

# TODO: how do we want to handle ErroneousNode or the equivalent error nodes?

FieldAccessByExpressionNode :: Node + FieldAccessNode
    @props
    expression              PrimaryExpressionNode                       | the expression from which the field is being selected
    identifier              IdentifierNode                              | the name of the field
    @docs
        Represents a field access, as in
        <pre>
        <i>expr</i>.<i>ident</i>
        </pre>
        For example, this node would allow the access of a fieldon the result of a method call using the code
        <pre>
        foo().bar
        </pre>
        This node is not used for simple expressions such as <tt>x</tt> or <tt>y.z</tt>.  For those forms of field
        access, see {@link FieldAccessByNameNode}.

FieldAccessByNameNode :: Node + FieldAccessNode
    @props
    name                    NameNode                                    | the name of the field to access
    @docs
        Represents a field access, as in
        <pre>
        <i>name</i>
        </pre>
        For example, this node would allow the access of a local variable <tt>x</tt> using the code
        <pre>
        x
        </pre>
        and allow the access of a <tt>bar</tt> field on a class <tt>Foo</tt> using the code
        <pre>
        Foo.bar
        </pre>
        This node is not used to represent field access from the evaluation result of a subexpression (such as in the
        code <tt>foo().bar</tt>).  For that form of access, see {@link FieldAccessByExpressionNode}.

InstanceOfNode :: Node + NonAssignmentExpressionNode
    @props
    expression              ExpressionNode                              | the expression being evaluated
    type                    TypeNode                                    | the type being checked
    @docs
        Represents the invocation of the <tt>instanceof</tt> operator, as in:
        <pre>
        <i>expression</i> instanceof <i>type</i>
        </pre>

LiteralNode<T>* :: Node + RestrictedPrimaryExpressionNode
    @props
    value                   T                                           | the literal value for this node
    @docs
        A superclass for all types of literal nodes.

MethodInvocationByExpressionNode :: MethodInvocationNode
    @props
    expression              PrimaryExpressionNode                       | the expression against which to invoke the method
    identifier              IdentifierNode                              | the name of the method to invoke
    @docs
        A node representing method invocation by expression, as in:
        <pre>
        <i>expr</i>.&lt;<i>typeArgs</i>&gt;<i>identifier</i>(<i>arg...</i>)
        </pre>
        For example, this node might be used when an expression produces an object against which we want to call a
        method as in
        <pre>
        new Object().toString()
        </pre>
        or
        <pre>
        foo().bar()
        </pre>
        For simple method invocations (such as <tt>myObjectReference.myMethod()</tt>), see
        {@link MethodInvocationByNameNode}.

MethodInvocationByNameNode :: MethodInvocationNode
    @props
    name                    NameNode                                    | the name of the method to invoke
    @docs
        A node representing method invocation by name, as in:
        <pre>
        <i>ambiguousName</i>.&lt;<i>typeArgs</i>&gt;<i>identifier</i>(<i>arg...</i>)
        </pre>
        or
        <pre>
        <i>methodName</i>(<i>arg...</i>)
        </pre>
        This node is used for simple method calls (such as <tt>x.y()</tt>) and not for expression-based method calls
        (such as <tt>x().y()</tt>).  For expression-based method calls, see {@link MethodInvocationByExpressionNode}.

MethodInvocationNode* :: Node + RestrictedPrimaryExpressionNode
    @props
    arguments               ListNode<ExpressionNode>                    | the arguments to pass to the method
    typeArguments           ListNode<TypeNode>                          | the type arguments for the method
    @docs
        A superclass for method invocation nodes.

ParenthesizedExpressionNode :: Node + RestrictedPrimaryExpressionNode
    @props
    expression              ExpressionNode                              | the expression contained in this node
    @docs
        A node representing a parenthesized expression, as in:
        <pre>
        (<i>expr</i>)
        </pre>
        This node is made explicit in this AST because Java distinguishes between primary expressions and other types
        of expressions.  For example, the ternary conditional operator (<tt>?:</tt>) is not a primary expression, but
        there is a big difference between <tt>b?x:y.z</tt> and <tt>(b?x:y).z</tt>.  However, the field selection node
        (which represents <tt>a.z</tt>) expects a primary expression; thus, without this node, there would be no way
        to express <tt>(b?x:y).z</tt>.

QualifiedClassInstantiationNode :: ClassInstantiationNode
    @props
    enclosingExpression     ExpressionNode                              | the expression enclosing the non-static inner class
    identifier              IdentifierNode                              | the name of the class being instantiated
    typeArguments           ListNode<TypeArgumentNode>                  | the type arguments to apply to the class being instantiated
    @docs
        A node representing the qualified instantiation of a class, as in:
        <pre>
        <i>expr</i>.new <i>type</i>(<i>arg...</i>)
        </pre>
        For example, consider the following code:
        <pre>
        public class Example
        {
            class A
            {
                class B
                {
                }
            }
            &nbsp;
            public void foo()
            {
                A a = new A();
                A.B b = a.new B(); // qualified instantiation
            }
        }
        </pre>

SuperFieldAccessNode :: Node + RestrictedPrimaryExpressionNode
    @props
    type                    UnparameterizedTypeNode                     | the qualifying type
    identifier              IdentifierNode                              | the identifier of the field being accessed
    @docs
        A node representing a field selection from <tt>super</tt>, such as in the expression
        <pre>
        <tt>super.myvar</tt>
        </pre>
        In some cases, it is possible for <tt>super</tt> to be qualified with a type, such as in the following
        convoluted example:
        <pre>
        public class A {
            protected int x = 0;
        }
        public class B extends A {
            protected int x = 1;
            public class C {
                public void foo() {
                    System.out.println(B.super.x);
                }
            }
        }
        </pre>
        Calling the <tt>foo</tt> method on the <tt>B.C</tt> class would print <tt>0</tt> rather than <tt>1</tt> because
        <tt>super</tt> is qualified with the enclosing class <tt>B</tt>.  Therefore, the field is selected from the
        enclosing instance's superclass (<tt>A</tt>) rather than the inner class's superclass (<tt>Object</tt>).  If a
        type qualification is not necessary (and it usually won't be), <tt>type</tt> should be <tt>null</tt>.

SuperMethodInvocationNode :: Node + RestrictedPrimaryExpressionNode
    @props
    type                    UnparameterizedTypeNode                     | the qualifying type
    identifier              IdentifierNode                              | the identifier of the method being invoked
    arguments               ListNode<ExpressionNode>                    | the arguments to pass to the method
    typeArguments           ListNode<TypeNode>                          | the type arguments for the method
    @docs
        A node representing a method invocation from <tt>super</tt>, such as in the expression
        <pre>
        <tt>super.toString()</tt>
        </pre>
        In some cases, it is possible for <tt>super</tt> to be qualified with a type, such as in the following
        convoluted example:
        <pre>
        public class A {
            public void foo() {
                System.out.println(0);
            }
        }
        public class B extends A {
            public void foo() {
                System.out.println(1);
            }
            public class C {
                public void foo() {
                    B.super.foo();
                }
            }
        }
        </pre>
        Calling the <tt>foo</tt> method on the <tt>B.C</tt> class would print <tt>0</tt> rather than <tt>1</tt> because
        <tt>super</tt> is qualified with the enclosing class <tt>B</tt>.  Therefore, the method is invoked from the
        enclosing instance's superclass (<tt>A</tt>) rather than the inner class's superclass (<tt>Object</tt>).  If a
        type qualification is not necessary (and it usually won't be), <tt>type</tt> should be <tt>null</tt>.

ThisNode :: Node + RestrictedPrimaryExpressionNode
    @props
    type                    UnparameterizedTypeNode                     | the qualifying type
    @docs
        A node representing the code snippet <tt>this</tt> in terms of a value, such as in the expression
        <pre>
        Object o = this;
        </pre>
        In some cases (especially in inner classes), <tt>this</tt> may be qualified with a type, such as in
        <pre>
        public class A {
            int x = 0;
            class B {
                int x = 0;
                public void foo() {
                    A.this.x++;
                }
            }
        }
        </pre>
        In that case, the <tt>type</tt> field contains the name of the qualified <tt>this</tt>.  Usually, <tt>this</tt>
        is unqualified and the <tt>type</tt> field is <tt>null</tt>.

TypeCastNode :: Node + NonAssignmentExpressionNode
    @props
    expression              ExpressionNode                              | the expression to cast
    type                    TypeNode                                    | the type to which to cast
    @docs
        A node for typecast expressions, as in:
        <pre>
        (<i>type</i>) <i>expr</i>
        </pre>

UnaryOperatorNode :: Node + NonAssignmentExpressionNode
    @props
    expression              ExpressionNode                              | the expression on which to operate
    operator                UnaryOperator                               | the operator to apply
    @docs
        A node for unary expressions, such as:
        <pre>
        ~0
        </pre>
        or
        <pre>
        x++
        </pre>

UnqualifiedClassInstantiationNode :: ClassInstantiationNode
    @props
    type                    DeclaredTypeNode                            | the type being instantiated
    @docs
        A node representing the instantiation of a class, as in:
        <pre>
        new <i>type</i>(<i>arg...</i>)
        </pre>
        If this class is not anonymous, the <tt>body</tt> field is <tt>null</tt>.

### Statement Nodes ###################################################################################################

AssertStatementNode :: Node + StatementNode
    @props
    testExpression          ExpressionNode                              | the assertion's test expression
    messageExpression       ExpressionNode                              | the assertion's message expression
    @docs
        Represents an assert statement, as in
        <pre>
            assert <i>expr</i>;
        </pre>
        or
        <pre>
            assert <i>expr</i> : <i>expr</i>;
        </pre>

BlockStatementNode :: Node + StatementNode
    @props
    statements              ListNode<StatementNode>                     | the statements contained in this block statement
    @docs
        Represents a block of statements, as in
        <pre>
        {
            <i>statement</i>
            <i>...</i>
        }
        </pre>
    
BreakNode :: Node + StatementNode
    @props
    label                   IdentifierNode                              | the break label
    @docs
        A node representing break statements, as in:
        <pre>
            break <i>label</i>;
        </pre>

ContinueNode :: Node + StatementNode
    @props
    label                   IdentifierNode                              | the continue label
    @docs
        A node representing continue statements, as in:
        <pre>
            continue <i>label</i>;
        </pre>

DoWhileLoopNode :: Node + StatementNode
    @props
    condition               ExpressionNode                              | the loop's condition
    statement               StatementNode                               | the loop's statement
    @docs
        A node representing a do-while loop, as in:
        <pre>
        do <i>body</i> while (<i>condition</i>);
        </pre>

EnhancedForLoopNode :: Node + StatementNode
    @props
    variable                VariableNode                                | the iterator variable
    expression              ExpressionNode                              | the loop's iterable expression
    statement               StatementNode                               | the loop's statement
    @docs
        A node representing a for-each loop, as in:
        <pre>
        for (<i>variable</i> : <i>expression</i>)
            <i>body</i>
        </pre>

# TODO: not every expression can be a statement in Java.  Create a suitable tagging interface.
ExpressionStatementNode :: Node + StatementNode
    @props
    expression              ExpressionNode                              | this statement's expression
    @docs
        A node representing an expression statement.  This allows any expression to be used as a statement and its
        value discarded.
    
ForLoopNode :: Node + StatementNode
    @props
    initializer             ForInitializerNode                          | the initializer used for this for loop
    condition               ExpressionNode                              | the loop's termination condition
    update                  ListNode<ExpressionStatementNode>           | the loop's update operation
    statement               StatementNode                               | the loop's statement
    @docs
        A node representing a for-loop, as in:
        <pre>
        for (<i>initializers</i>; <i>condition</i>; <i>updaters</i>)
            <i>body</i>
        </pre>
        If the loop has no initializers, the <tt>initializer</tt> field is <tt>null</tt>.  If the loop has no updates,
        the <tt>update</tt> field is a {@link ListNode} with no children.  If the loop has no termination condition, the
        <tt>condition</tt> field is <tt>null</tt>.  The <tt>update</tt> field should never be <tt>null</tt>.
    
IfNode :: Node + StatementNode
    @props
    condition               ExpressionNode                              | the condition
    thenStatement           StatementNode                               | the then branch's statement
    elseStatement           StatementNode                               | the else branch's statement
    @docs
        A node representing an if-then-else statement, as in:
        <pre>
        if (<i>condition</i>) then <i>statement</i> else <i>statement</i>
        </pre>

InlineTypeDeclarationNode :: Node + StatementNode
    @props
    declaration             InlineTypeDeclarableNode                    | the type declaration
    @docs
        A node representing an inline type declaration.  This is used to allow classes and enums to be declared
        within a method body or similar environment.
    
LabeledStatementNode :: Node + StatementNode
    @props
    label                   IdentifierNode                              | the statement's label
    statement               StatementNode                               | the statement being labeled
    @docs
        A node representing labeled statements, as in:
        <pre>
        <i>identifier</i>: <i>statement</i>
        </pre>

ReturnNode :: Node + StatementNode
    @props
    expression              ExpressionNode                              | the expression to return
    @docs
        A node representing a return statement, as in;
        <pre>return <i>expr</i>;</pre>
        or
        <pre>return;</pre>
        For void return statements, the <tt>expression</tt> is <tt>null</tt>.
    
SwitchNode :: Node + StatementNode
    @props
    expression              ExpressionNode                              | the expression over which to switch
    cases                   ListNode<CaseNode>                          | the cases in this switch
    @docs
        A node to represent switch statements, as in:
        <pre>
        switch (<i>expr</i>) {
            case <i>value</i>:
            ...
        }
        </pre>

SynchronizedNode :: Node + StatementNode
    @props
    expression              ExpressionNode                              | the synchronization expression
    block                   BlockStatementNode                          | the block of statements to synchronize
    @docs
        A node to represent synchronization statements, as in:
        <pre>
        synchronized (<i>expr</i>) {
            ...
        }
        </pre>

ThrowNode :: Node + StatementNode
    @props
    expression              ExpressionNode                              | the Throwable to throw
    @docs
        A node to represent throw statements, as in:
        <pre>
        throw <i>expr</i>;
        </pre>

TryNode :: Node + StatementNode
    @props
    block                   BlockStatementNode                          | the block in which to try
    catches                 ListNode<CatchNode>                         | the catch conditions
    finallyBlock            BlockStatementNode                          | the finally block
    @docs
        A node to represent a try-catch block, as in:
        <pre>
        try <i>block</i>
        catch (<i>type name</i>) <i>block</i>
        </pre>
        or
        <pre>
        try <i>block</i>
        catch (<i>type name</i>) <i>block</i>
        catch (<i>type name</i>) <i>block</i>
        finally <i>block</i>
        </pre>
        If no catch block exists, the <tt>catches</tt> list node will contain no children.  If no finally block exists,
        <tt>finallyBlock</tt> will be <tt>null</tt>.  <tt>catches</tt> is not permitted to be <tt>null</tt>.

VariableDeclarationNode :: Node + StatementNode
    @props
    modifiers               ModifiersNode                               | the modifiers for this variable
    declarators             ListNode<VariableDeclaratorNode>            | the variable declarators for this node
    @docs
        A node for the declaration of a variable, as in:
            <pre>
            <i>type identifier</i>;
            </pre>
        or
            <pre>
            <i>type identifier</i> = <i>expression</i>;
            </pre>
        or
            <pre>
            <i>type identifier</i> = <i>expression</i>, <i>identifier</i> = <i>expression</i>, ...;

VariableDeclaratorNode :: Node + StatementNode
    @props
    type                    TypeNode                                    | the type of this variable
    name                    IdentifierNode                              | the name of this variable
    initializer             VariableInitializerNode                     | the initializer to use
    @docs
        Represents a declarator for a variable declaration.  For example, in
        <pre>int x = 5, y;</pre>
        this node either represents
        <pre>x = 5</pre>
        or
        <pre>y</pre>
        .  Note that variable multi-declaration syntax allows different types, as in
        <pre>int x = 5, y[] = new int[2];</pre>
        Hence, type exists on this node instead of its parent.  If the variable is not initialized, the
        <tt>initializer</tt> field is <tt>null</tt>.
        
VoidStatementNode :: Node + StatementNode
    @docs
        A node representing a void statement, as in
        <pre>;</pre>        

WhileLoopNode :: Node + StatementNode
    @props
    condition               ExpressionNode                              | the loop's condition
    statement               StatementNode                               | the loop's statement
    @docs
        A node for a while loop, as in:
        <pre>
        while (<i>condition</i>)
            statement
        </pre>

### Type Nodes ########################################################################################################

ArrayTypeNode :: Node + ReferenceTypeNode, LiteralizableTypeNode
    @props
    type                    TypeNode                                    | the element type of the array
    @docs
        Represents an array type.

ParameterizedTypeNode :: Node + DeclaredTypeNode
    @props
    baseType                UnparameterizedTypeNode                     | the base type being parameterized
    typeArguments           ListNode<TypeArgumentNode>                  | the type arguments for this node
    @docs
        A node representing parameterized types.  This node represents the use of a type which has type arguments, such
        as Set<String> (which would be represented by the unparameterized type Set and the single-element argument list
        containing the unparameterized type for String).

ParameterizedTypeSelectNode :: Node + DeclaredTypeNode
    @props
    base                    ParameterizedTypeNode                       | the parameterized type from which a type is selected
    select                  DeclaredTypeNode                            | the type which is selected from the base
    @docs
        A node representing a type selection from a parameterized type.  This node is used when a type is selected from
        another type which is parameterized, such as in <tt>A&lt;X&gt;.B</tt>.  In that case, the root node is a
        <tt>ParameterizedTypeSelectNode</tt>.  The <tt>select</tt> child is an <tt>UnparameterizedTypeNode</tt>
        containing the name "B"; the <tt>base</tt> child is a {@link ParameterizedTypeNode}.  The <tt>base</tt> has
        children of an {@link UnparameterizedTypeNode} containing the name "A" and a {@link ListNode} containing the
        type argument with the name "X".

PrimitiveTypeNode :: Node + TypeNode, BaseTypeNode, LiteralizableTypeNode
    @props
    primitiveType           PrimitiveType                               | the primitive type being represented
    @docs
        A node representing a primitive type.

# TODO: add information which tracks whether we have determined this node to represent a true declared type or type parameter
UnparameterizedTypeNode :: Node + DeclaredTypeNode, LiteralizableTypeNode
    @props
    name                    NameNode                                    | the name of the type
    @docs
        Represents an unparameterized type.  Examples of unparameterized types in Java include most of the API: String,
        InputStream, and so on.  Parameterized types, such as Set<String>, are not represented in this way.
        Unparameterized types also represent type parameters, such as the <tt>T</tt> in <tt>Set<T></tt>.

VoidTypeNode :: Node + TypeNode, LiteralizableTypeNode
    @docs
        A node representing the void type.  This is used, for example, in method return values.

### Literal Nodes #####################################################################################################

BooleanLiteralNode :: LiteralNode<Boolean>
    @docs
        A node representing a boolean literal.

CharLiteralNode :: LiteralNode<Character>
    @docs
        A node representing a character literal.

ClassLiteralNode :: LiteralNode<LiteralizableTypeNode>
    @docs
        A note representing a class literal, such as <tt>String.class</tt>.  Note that the BSJ compiler API includes a
        {@link VoidTypeNode}.  This is technically a violation (as Java does not treat <tt>void</tt> as a type) but
        allows this node to represent <tt>void.class</tt>.

DoubleLiteralNode :: LiteralNode<Double>
    @docs
        A node representing a double literal.

FloatLiteralNode :: LiteralNode<Float>
    @docs
        A node representing a float literal.

IntLiteralNode :: LiteralNode<Integer>
    @docs
        A node representing an int literal.

LongLiteralNode :: LiteralNode<Long>
    @docs
        A node representing a long literal.

NullLiteralNode :: LiteralNode<Void>
    @docs
        A node representing a null literal.

StringLiteralNode :: LiteralNode<String>
    @docs
        A node representing a String literal.
        
### Member Nodes ######################################################################################################

AnnotationMethodDeclarationNode :: Node + AnnotationMemberNode
    @props
    modifiers               ModifiersNode                               | the modifiers for this annotation method
    type                    TypeNode                                    | the return type of this annotation method
    identifier              IdentifierNode                              | this annotation method's name
    defaultValue            AnnotationValueNode                         | the default value for this method
    @docs
        A node representing an annotation method declaration, as in:
        <pre>
            <i>modifiers type identifier</i> () default <i>defaultValue</i>;
        </pre>

ConstructorDeclarationNode :: Node + ClassMemberNode
    @props
    body                    ConstructorBodyNode                         | the body of this constructor
    modifiers               ModifiersNode                               | the modifiers for this constructor
    parameters              ListNode<VariableNode>                      | the parameters declared by this constructor
    varargParameter         VariableNode                                | the vararg parameter declared by this method
    throwTypes              ListNode<UnparameterizedTypeNode>           | the types of exceptions thrown by this constructor
    typeParameters          ListNode<TypeParameterNode>                 | this constructor's applicable type parameters
    @docs
        A node representing a constructor declaration, as in:
        <pre>
            <i>modifiers typeParams typeName</i>(<i>parameter...</i>) throws <i>expr...</i>
                <i>body</i>
        </pre>
        See {@link MethodDeclarationNode} for more information.

EnumConstantDeclarationNode :: Node
    @props
    annotations             ListNode<AnnotationNode>                    | the annotations on this constant
    identifier              IdentifierNode                              | the name of this constant
    arguments               ListNode<ExpressionNode>                    | the arguments to the enum constructor
    body                    AnonymousClassBodyNode                      | the body used to anonymously subclass the constant
    @docs
        A node representing an enum constant.  While enum constants typically consist of a single name, many optional
        extensions exist.  In the likely case that this constant is not an anonymous subclass, <tt>body</tt> is
        <tt>null</tt>.

FieldDeclarationNode :: Node + ClassMemberNode, InterfaceMemberNode, AnnotationMemberNode, AnonymousClassMemberNode
    @props
    modifiers               ModifiersNode                               | the modifiers for this field
    declarators             ListNode<VariableDeclaratorNode>            | the variable declarators for this node
    @docs
        A node representing a field declaration.  Constants are represented by this node as well.

InitializerDeclarationNode :: Node + ClassMemberNode, AnonymousClassMemberNode
    @props
    staticInitializer       boolean                                     | whether or not the initializer is static
    body                    BlockStatementNode                          | the body of the initializer

MethodDeclarationNode :: Node + ClassMemberNode, InterfaceMemberNode, AnonymousClassMemberNode
    @props
    body                    BlockStatementNode                          | the body of this method
    modifiers               ModifiersNode                               | the modifiers for this method
    identifier              IdentifierNode                              | this method's name
    parameters              ListNode<VariableNode>                      | the parameters declared by this method
    varargParameter         VariableNode                                | the vararg parameter declared by this method
    returnType              TypeNode                                    | the type of value returned
    throwTypes              ListNode<UnparameterizedTypeNode>           | the types of exceptions thrown by this method
    typeParameters          ListNode<TypeParameterNode>                 | this method's applicable type parameters
    @docs
        A node representing a method declaration, as in:
        <pre>
            <i>modifiers typeParams type name</i>(<i>parameter...</i>) throws <i>expr...</i>
                <i>body</i>
        </pre>
        Note that the vararg parameter is used in cases where a variable argument is used, such as in
        <pre>
            public void foo(String... vararg)
        </pre>
        The type on the <tt>varargParameter</tt> node should be <tt>String</tt> in the above case (and <i>not</i>
        <tt>String[]</tt>).  Also observe that methods with no body, such as the abstract method
        <pre>public abstract void foo();</pre>
        will have a <tt>null</tt> body.

### Type Body Nodes ####################################################################################################

AnnotationBodyNode :: Node
    @props
    members             ListNode<AnnotationMemberNode>                  | the members of this annotation body
    @docs
        Represents the body of an annotation declaration.

AnonymousClassBodyNode :: Node
    @props
    members             ListNode<AnonymousClassMemberNode>              | the members of this anonymous class body
    @docs
        Represents the body of an anonymous class declaration.  This body is distinct from {@link ClassBodyNode} in that
        it does not permit constructors.  There is no corresponding <tt>AnonymousClassDeclarationNode</tt> because the
        expression which contains this body implicitly stands as the declaration of that type.

ClassBodyNode :: Node
    @props
    members             ListNode<ClassMemberNode>                       | the members of this class body
    @docs
        Represents the body of a class declaration.

EnumBodyNode :: Node
    @props
    constants           ListNode<EnumConstantDeclarationNode>           | the enumeration constants
    members             ListNode<ClassMemberNode>                       | the members of the class body part
    @docs
        Represents the body of an enum declaration.

InterfaceBodyNode :: Node
    @props
    members             ListNode<InterfaceMemberNode>                       | the members of this interface body
    @docs
        Represents the body of an interface declaration.

### Type Declaration Nodes ############################################################################################

AnnotationDeclarationNode :: NamedTypeDeclarationNode
    @props
    body                    AnnotationBodyNode                          | this annotation's body
    @docs
        Represents the declaration of an annotation, as in:
        <pre>
        <i>modifiers</i> @interface <i>name</i>
        {
            <i>member</i>
            ...
        }
        </pre>

ClassDeclarationNode :: NamedTypeDeclarationNode + InlineTypeDeclarableNode
    @props
    extendsClause           TypeNode                                    | the extends clause
    implementsClause        ListNode<TypeNode>                          | the implements clause
    body                    ClassBodyNode                               | the body of this class
    typeParameters          ListNode<TypeParameterNode>                 | this class's type parameters
    @docs
        Represents the declaration of a class, as in:
        <pre>
        <i>modifiers<i> class <i>name</i>&lt;<i>typeParam...</i>&gt; extends <i>type</i> implements <i>type...</i>
        {
            <i>member</i>
            <i>...</i>
        }
        </pre>
        
EnumDeclarationNode :: NamedTypeDeclarationNode + InlineTypeDeclarableNode
    @props
    implementsClause        ListNode<TypeNode>                          | the implements clause
    body                    EnumBodyNode                                | this enum's body
    @docs
        Represents the declaration of a class, as in:
        <pre>
        <i>modifiers<i> enum <i>name</i> implements <i>type...</i>
        {
            <i>member</i>
            <i>...</i>
        }
        </pre>

InterfaceDeclarationNode :: NamedTypeDeclarationNode
    @props
    extendsClause           ListNode<TypeNode>                          | the extends clause
    body                    InterfaceBodyNode                           | this interface's body
    typeParameters          ListNode<TypeParameterNode>                 | this class's type parameters
    @docs
        Represents the declaration of an interface, as in:
        <pre>
        <i>modifiers<i> interface <i>name</i>&lt;<i>typeParam...</i>&gt; extends <i>type...</i>
        {
            <i>member</i>
            <i>...</i>
        }
        </pre>

NamedTypeDeclarationNode* :: Node + TypeDeclarationNode
    @props
    identifier              IdentifierNode                              | the name of this declared type
    modifiers               ModifiersNode                               | the modifiers for this declared type
    @docs
        Acts as a superclass for all named type declarations.

VoidTypeDeclarationNode :: Node + TypeDeclarationNode
    @docs
        Represents the void declaration (a single semi-colon).

### Annotation Nodes ##################################################################################################

AnnotationAnnotationValueNode :: Node + AnnotationValueNode
    @props
    annotation              AnnotationNode                              | the annotation
    @docs
        A value in an annotation which is another annotation.  This node is used for complex annotations, such as
        <pre>@Foo(a=@Bar)</pre>
        In the above snippet, this node would represent the
        <pre>@Bar</pre>
        portion.

AnnotationArrayValueNode :: Node + AnnotationValueNode
    @props
    values                  ListNode<AnnotationValueNode>               | the array values
    @docs
        A value in an annotation representing an array.  This node is distinct from the {@link ArrayInitializerNode}
        because it allows annotations (by way of {@link AnnotationAnnotationValueNode}) as well as expressions.

AnnotationExpressionValueNode :: Node + AnnotationValueNode
    @props
    expression              NonAssignmentExpressionNode                 | the expression
    @docs
        A value in an annotation which is an expression.  This value may not be an assignment expression.

AnnotationNode* :: Node
    @props
    annotationType          UnparameterizedTypeNode                     | the annotation type
    @docs
        Acts as a base class for annotation nodes.  Subclasses distinguish between the different types of annotation
        sugar.

AnnotationElementNode :: Node
    @props
    identifier              IdentifierNode                              | the identifier
    value                   AnnotationValueNode                         | the element's value
    @docs
        Represents an annotation element, as in
        <pre>
        <i>ident</i>=<i>value</i>
        </pre>

NormalAnnotationNode :: AnnotationNode
    @props
    arguments               ListNode<AnnotationElementNode>             | the arguments
    @docs
        Represents the usage of an annotation, as in:
        <pre>@<i>type</i></pre>
        or
        <pre>@<i>type</i>(<i>key</i>=<i>value</i>,...)</pre>
        Note that this node does not handle the single element annotation format (<pre>@Foo("bar")</pre>).  That is
        handled by the {@link SingleElementAnnotationNode} class.

SingleElementAnnotationNode :: AnnotationNode
    @props
    value                   AnnotationValueNode                         | the value of the "value" element
    @docs
        Represents a single element annotation, as in:
        <pre>@<i>type</i>(<i>value</i>)</pre>

### Base Nodes ########################################################################################################

AlternateConstructorInvocationNode :: ConstructorInvocationNode
    @docs
        Represents an alternate constructor invocation, as in
        <pre>
        this("foo")
        </pre>
        Note that this only applies to <i>alternate</i> constructor invocations (those using the <tt>this</tt> keyword).
        For superclass constructor invocations, see {@link SuperclassConstructorInvocationNode}.

ArrayInitializerNode :: Node + VariableInitializerNode
    @props
	initializers            ListNode<VariableInitializerNode>           | the initializers for the array
    @docs
        A node representing the initialization of an array, as in:
        <pre>
        {<i>initializer</i>,...}
        </pre>
        The resulting array contains one element for each initializer expression.

CaseNode :: Node
    @props
    expression              ExpressionNode                              | the expression used in this case label
    statements              ListNode<StatementNode>                     | the statements to execute in this case node
    @docs
        A node representing a switch's case block, as in:
        <pre>
        case <i>expression</i>:
            <i>statement</i>
            <i>...</i>
        </pre>
        or
        <pre>
        default:
            <i>statement</i>
            <i>...</i>
        </pre>
        If the switch label is <tt>default</tt>, <tt>expression</tt> is <tt>null</tt>. 

CatchNode :: Node
    @props
    block                   BlockStatementNode                          | the block to execute when this catch occurs
    parameter               VariableNode                                | this catch block's exception variable
    @docs
        A node representing a catch block, as in
        <pre>
        catch (<i>type identifier</i>)
            <i>block</i>
        </pre>

CompilationUnitNode :: Node
    @props
    packageDeclaration      PackageDeclarationNode                      | the package declaration for this unit
    imports                 ListNode<ImportNode>                        | the imports used in this unit
    typeDecls               ListNode<TypeDeclarationNode>               | the type declarations of this unit
    @docs
        Represents a BSJ compilation unit.
    # TODO: do we want sourceFile of type JavaFileObject here or something similar?

ConstructorBodyNode :: Node
    @props
    constructorInvocation   ConstructorInvocationNode                   | the (nullable) constructor invocation
    statements              ListNode<StatementNode>                     | the statements contained in this constructor
    @docs
        Represents a constructor body.  For example, in
        <pre>
        public MyClass()
        {
            super();
            this.foo = 0;
        }
        </pre>
        this node would represent all but the first line.  Observe that this structure enforces the Java language rule
        that there be exactly one explicit constructor invocation and that it appears at the top of the constructor
        body.

ConstructorInvocationNode* :: Node
    @props
    arguments               ListNode<ExpressionNode>                    | the arguments to pass to the method
    typeArguments           ListNode<TypeNode>                          | the type arguments for the method
    @docs
        This class is a common superclass to both types of explicit constructor invocations: alternate constructor
        invocations (those using the <tt>this</tt> keyword) and superclass constructor invocations (those using the
        <tt>super</tt> keyword).  This distinction is made because, despite their similarities in use and syntax, the
        language specification treats these two entities as distinct (and there are some corner cases for the superclass
        constructor syntax which are best contained

ForInitializerDeclarationNode :: Node + ForInitializerNode
    @props
    declaration             VariableDeclarationNode                     | the variables declared in this initializer
    @docs
        Represents a for loop initializer which declares variables.  For example, in
        <pre>for (int i=0;i<n;i++)</pre>
        this node represents
        <pre>int i=0</pre>
        Note that, due to the nature of {@link VariableDeclarationNode}, this can be a variable muilti-declaration.

ForInitializerExpressionNode :: Node + ForInitializerNode
    @props
    expressions             ListNode<ExpressionNode>                    | the expressions used in this initializer
    @docs
        Represents a for loop initializer which contains expressions.  For example, in
        <pre>for (i=0,j=0;i<n || j<m;i++,j++)</pre>
        this node represents
        <pre>i=0,j=0</pre>
# TODO: this node should not be able to use any expression which is not applicable as a statement - fix the type

ImportOnDemandNode :: Node + ImportNode
    @props
    name                    NameNode                                    | the name of the package to import
    staticImport            boolean                                     | the static-ness of the import
    @docs
        A node representing an on-demand import statement, such as "<tt>import java.util.*</tt>".

ImportSingleTypeNode :: Node + ImportNode
    @props
    name                    NameNode                                    | the name of the type to import
    staticImport            boolean                                     | the static-ness of the import
    @docs
        A node representing a single type import statement, such as "<tt>import java.util.Set</tt>".

!set stopGen=cons,children

ListNode<T extends Node> :: Node
    @props
    children*               List<T>                                     | the list of children  
    @docs
        Represents a list of nodes.  Nodes do not simply have lists as properties as the ListNode allows additional
        information to be tracked as necessary.
    @include
        ListNode.java

!set stopGen=

ModifiersNode :: Node
    @props
    annotations             ListNode<AnnotationNode>                    | the annotations modifying the subject
    flags                   Set<Modifier>                               | the modifiers set on the subject
    @docs
        A node representing the modifiers applied to another node.  Modifiers may include flags (such as <tt>final</tt>
        or <tt>strictfp</tt>) and annotations (such as <tt>@Override</tt>).
    
Node*
    @props
    @include
        Node.java
    @docs
        The parent class for all BSJ AST nodes.

PackageDeclarationNode :: Node
    @props
    name                    NameNode                                    | the name of the package
    annotations             ListNode<AnnotationNode>                    | the annotations on the package declaration
    @docs
        A node representing a package declaration, as in
        <pre>
            package <i>packageName</i>;
        </pre>
        or
        <pre>
            <i>annotations</i>
            package <i>packageName</i>;
        </pre>

SuperclassConstructorInvocationNode :: ConstructorInvocationNode
    @props
    qualifyingExpression    PrimaryExpressionNode                       | the qualifying expression for the enclosing object
    @docs
        Represents an alternate constructor invocation, as in
        <pre>
        super("foo")
        </pre>
        or in the rarer syntax
        <pre>
        (new Foo()).super(0)
        </pre>
        .  Note that this only applies to <i>superclass</i> constructor invocations (those using the <tt>super</tt>
        keyword).  For alternate constructor invocations, see {@link AlternateConstructorInvocationNode}.

TypeParameterNode :: Node
    @props
    identifier              IdentifierNode                              | the base type name for the parameter
    bounds                  ListNode<DeclaredTypeNode>                  | the bounds over the base type
    @docs
        A node for type parameters, as in:
        <pre>
        <i>ident</i>
        </pre>
        or
        <pre>
        <i>ident</i> extends <i>type</i>
        </pre>
        or
        <pre>
        <i>ident</i> extends <i>type</i> &amp; <i>type...</i>
        </pre>
        
VariableNode :: Node
    @props
    modifiers               ModifiersNode                               | the modifiers of this parameter
    type                    TypeNode                                    | the type of the variable
    identifier              IdentifierNode                              | the name of the variable
    @docs
        A node describing a variable, as in:
            <pre>
            <i>type identifier</i>
            </pre>        

WildcardTypeNode :: Node + TypeArgumentNode
    @props
    bound                   ReferenceTypeNode                           | the wildcard's bound
    upperBound              boolean                                     | whether or not the wildcard's bound is an upper (<tt>extends</tt>) bound
    @docs
        A nore for wildcard type parameters, as in:
        <pre>
        ? extends <i>type</i>
        </pre>
        (in which case <tt>bound</tt> is non-<tt>null</tt> and <tt>upperBound</tt> is <tt>true</tt>) or
        <pre>
        ? super <i>type</i>
        </pre>
        (in which case <tt>bound</tt> is non-<tt>null</tt> and <tt>upperBound</tt> is <tt>false</tt>) or
        <pre>
        ?
        </pre>
        (in which case <tt>bound</tt> is <tt>null</tt>).

#######################################################################################################################
# BSJ AST NODES
#######################################################################################################################

!set iPackage=edu.jhu.cs.bsj.compiler.ast.node.meta
!set cPackage=edu.jhu.cs.bsj.compiler.impl.ast.node.meta

# TODO

CodeLiteralNode :: LiteralNode<Node>
    @docs
        A node representing a code literal.
