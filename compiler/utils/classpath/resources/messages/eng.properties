bsj.compiler.compilation.java.error=A Java compiler error has occurred: %{diagnosticMessage}$s
# TODO: bsj.compiler.conflict.injection
# TODO: bsj.compiler.dependency.cycle
# TODO: bsj.compiler.metaAnnotation.abstract
# TODO: bsj.compiler.metaAnnotation.inappropriateArrayInitializer
# TODO: bsj.compiler.metaAnnotation.missingClass
# TODO: bsj.compiler.metaAnnotation.typeMismatch
bsj.compiler.metaAnnotation.method.name=The meta-annotation definition for %{metaAnnotationClass}$s is invalid; the %{#methodTypeCode}$s method named %{methodName}$s is incorrectly named.
bsj.compiler.metaAnnotation.method.parameterCount=The meta-annotation definition for %{metaAnnotationClass}$s is invalid; the %{#methodTypeCode}$s method named %{methodName}$s has an inappropriate number of parameters (has %{observedCount}$d, expected %{expectedCount}$d).
bsj.compiler.metaAnnotation.method.returnType=The meta-annotation definition for %{metaAnnotationClass}$s is invalid; the %{#methodTypeCode}$s method named %{methodName}$s has an incorrect return type.
bsj.compiler.metaAnnotation.method.static=The meta-annotation definition for %{metaAnnotationClass}$s is invalid; the %{#methodTypeCode}$s method named %{methodName}$s is static.
bsj.compiler.metaAnnotation.property.missing=Property %{propertyName}$s is not defined on %{metaAnnotationClass}$s.  Are the getter and setter present and properly annotated?
bsj.compiler.metaAnnotation.property.missingMethod=The meta-annotation definition for %{metaAnnotationClass}$s is invalid; the property %{propertyName}$s has no %{#methodTypeCode}$s method.
# TODO: bsj.compiler.metaAnnotation.property.nonconstant
bsj.compiler.metaAnnotation.property.typeMismatch=The meta-annotation definition for %{metaAnnotationClass}$s is invalid; property %{propertyName}$s has a getter whose return type is not assignable from the argument type of the setter.
bsj.compiler.metaprogram.dependency.empty=Target %{name}$s contains no metaprograms.
bsj.compiler.metaprogram.dependency.resolution.typeName=Target contains unresolvable type name %{typeName}$s.
# TODO: bsj.compiler.metaprogram.failure.conflict.attribute 
bsj.compiler.metaprogram.failure.conflict.list=A list node is in conflict as described below due to previous operations:\n%{conflictKnowledge}$s
# TODO: bsj.compiler.metaprogram.failure.duplicate.packageMember
# TODO: bsj.compiler.metaprogram.failure.exception
# TODO: bsj.compiler.metaprogram.failure.general
# TODO: bsj.compiler.metaprogram.failure.permission
# TODO: bsj.compiler.metaprogram.node.parent.multiple
bsj.compiler.metaprogram.subcompilation.failure=Compilation of a metaprogram has failed: %{diagnosticMessage}$s

bsj.lexer.error.generalFailure=A general lexer failure has occurred.

bsj.parser.error.conflictingAccessModifier=Access modifiers "%{firstModifier}$s" and "%{secondModifier}$s" conflict.
bsj.parser.error.conflictingMode=Modes "%{firstMode}$s" and "%{secondMode}$s" conflict.
bsj.parser.error.duplicateMode=Duplicate mode "%{mode}$s".
bsj.parser.error.duplicateModifier=Duplicate modifier "%{modifier}$s".
bsj.parser.error.extraneousToken=Extraneous token "%{extraneousToken}$s".
bsj.parser.error.generalParseFailure=Parse failure at "%{tokenText}$s".
bsj.parser.error.invalidFloatingPointLiteral.tooLarge=Floating point literal too large: "%{literalText}$s".
bsj.parser.error.invalidFloatingPointLiteral.tooSmall=Floating point literal too small: "%{literalText}$s".
bsj.parser.error.invalidIntegerLiteral=Invalid integer literal: "%{literalText}$s".
bsj.parser.error.invalidMode=Invalid mode: "%{mode}$s".
bsj.parser.error.invalidModifier=Invalid modifier: "%{modifier}$s".
bsj.parser.error.invalidSingleStaticImportName=Unqualified single static import name "%{name}$s" is illegal.
bsj.parser.error.missingToken=Missing token of type %{tokenType}$s.
bsj.parser.error.unexpectedToken=Unexpected token %{tokenText}$s of type %{tokenType}$s when type %{expectedType}$s was expected.

bsj.string.MetaAnnotationMethodType.GETTER=getter
bsj.string.MetaAnnotationMethodType.SETTER=setter
bsj.string.stackTrace.element=from %s
bsj.string.part.metaprogram.failure.conflict.list.ruleKnowledgeSourceHeader=%{knowledge}$s because, by rule %{rule}$s,
bsj.string.part.metaprogram.failure.conflict.list.operationKnowledgeSourceHeader=%{knowledge}$s because of operation called

# TODO: bsj.typechecker.incorrectPackageDeclaration
# TODO: the following should include information about the source location of the ambiguous declarations.
bsj.typechecker.name.ambiguous=Ambiguous name %{name}s for symbol type %{symbolType}s.
# TODO: bsj.typechecker.name.unknown
